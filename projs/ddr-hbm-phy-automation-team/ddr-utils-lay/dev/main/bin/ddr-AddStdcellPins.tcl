#!/depot/tcl8.6.6/bin/tclsh
proc tutils__script_usage_statistics {toolname version} {
    set prefix "ddr-da-"
    set reporter "/remote/cad-rep/msip/tools/bin/msip_get_usage_info"
    set cmd ""
    set script_dirname [file dirname [file normalize [info script]]]
    append cmd "$reporter --tool_name  \"${prefix}${toolname}\" "
    append cmd "--stage main --category ude_ext_1 "
    append cmd "--tool_path \"$script_dirname\" --tool_version \"$version\""

    exec sh -c $cmd
}

set script_name [file tail [file rootname [file normalize [info script]]]]
tutils__script_usage_statistics $script_name "2022ww16"

#Define user TCL command msip::OpenCloseAllCellsOfLibrary
namespace eval alpha::addStdcellPins {
    proc execute {args} {
	puts "$args"
	array set myArgs $args
	set cmd [list]
	
	::utils::alpha::addStdcellPinsProc $myArgs(-libName) $myArgs(-viewName) $myArgs(-headlessMode) $myArgs(-ignoreCellsFile)
	##  Not sure why all the "if [info exist myArgs()]";  Args must exist.
	#	if [info exists myArgs(-libName)] {
	#	    lappend cmd $myArgs(-libName)
#	}
#	if [info exists myArgs(-viewName)] {
 #   	    lappend cmd $myArgs(-viewName)
#	}
#	if [info exists myArgs(-headlessMode)] {
#    	    lappend cmd $myArgs(-headlessMode)
#	}
#	if [info exists myArgs(-ignoreCellsFile)] {
#    	    lappend cmd $myArgs(-ignoreCellsFile)
#	}
#	return [eval $cmd]

        #	lappend cmd ::utils::alpha::addStdcellPinsProc
        # larissa, Jule 04 2019. Added code for renaming instances in schematics 
        foreach libName $myArgs(-libName) {
	   puts "library $libName"
	   ::utils::alpha::inst_name_Update_ForLib $libName
	}

    }
}
 

namespace eval ::utils::alpha {
    ### The main routine ### 
    proc addStdcellPinsProc {libNameArg viewName headlessMode ignoreCellsFile } {
	global env
	global MSIP_CURRENT_CONTEXT
	global MSIP_CURRENT_LOG_FILE_POINTER
	global MSIP_CURRENT_LOG_FILE_NAME
	global MSIP_LIST_OF_OPEN_CONTEXTS
	
	set procName "addStdcellPins"
	set procVer   "0.0 (2016/11/22)"
	foreach libName $libNameArg {
	    set MSIP_CURRENT_LOG_FILE_NAME "./${procName}_${libName}.log"
	    set args [list $libName $viewName $headlessMode $ignoreCellsFile]
	    
	    ### Create LOG file ###
	    if {[catch  { open $MSIP_CURRENT_LOG_FILE_NAME w } MSIP_CURRENT_LOG_FILE_POINTER]} {
		puts "Couldn't create $MSIP_CURRENT_LOG_FILE_NAME file!\n"
		return
	    } else {
		puts $MSIP_CURRENT_LOG_FILE_POINTER "This log file is generated by $procName\(Ver. $procVer\)";
		puts $MSIP_CURRENT_LOG_FILE_POINTER "user: $env(USER)";
		puts $MSIP_CURRENT_LOG_FILE_POINTER "run time: [exec date]";
		puts $MSIP_CURRENT_LOG_FILE_POINTER "Command line arguments were following: $args\n";
	    }
	    
	    #Attech library to 'techlib' if not attached
	    #set oaTech [oa::TechFind $libName]
	    #set techlibName [db::getAttr libName -of [oa::TechFind $libName]]
	    #if {$techlibName != "techlib"} {
	       set oaLib [oa::LibFind $libName]
	       if {[catch  {oa::getAccess $oaLib write}] } {
	         puts $MSIP_CURRENT_LOG_FILE_POINTER "Error: cannot attach $libName to techlib: read-only access"
		 error "Read-only access for $libName"
		 return
	       } else {
		 db::attachTech $oaLib -refLibName "techlib"
	       } 
	    #}

	    set ignoreCellList {}
	    if {$ignoreCellsFile !=""} {
		set ignoreCellList [ReadIgnoreCellListFile $ignoreCellsFile]
	    } 
	    
	    de::sendMessage "Building context list" -severity information
	    if {[ThereAreLockedCellViewsInLib $libName $viewName $ignoreCellList]} {
		puts $MSIP_CURRENT_LOG_FILE_POINTER "Please unlock all cell views before running the script!\n"
		###Close open contexts###
		db::foreach ctx  [db::createCollection $MSIP_LIST_OF_OPEN_CONTEXTS] {
		    de::close $ctx
		}
		UnsetGlobals
		###Close log file ###
		close $MSIP_CURRENT_LOG_FILE_POINTER
		puts "log file is $MSIP_CURRENT_LOG_FILE_NAME"	
		xt::openTextViewer -files $MSIP_CURRENT_LOG_FILE_NAME
		return
	    }
	    
	    ### Body ###
	    de::sendMessage "Processing cells" -severity information
	    db::foreach MSIP_CURRENT_CONTEXT  [db::createCollection $MSIP_LIST_OF_OPEN_CONTEXTS] {
		processCell $MSIP_CURRENT_CONTEXT $MSIP_CURRENT_LOG_FILE_POINTER
		#            if {[catch {eval $command1} errmsg]} {
		#		error $errmsg
		#	    }
	    }
	    ### End ###
	    UnsetGlobals
	    puts $MSIP_CURRENT_LOG_FILE_POINTER "$procName finished normally.\n"
	    close $MSIP_CURRENT_LOG_FILE_POINTER
	    puts "log file is $MSIP_CURRENT_LOG_FILE_NAME"
	    xt::openTextViewer -files $MSIP_CURRENT_LOG_FILE_NAME
	}; #End of addStdcellPins
    }
    
    proc processCell  {ctx LOG} {
	
	set design [db::getAttr editDesign -of $ctx]
	set cellName [ oa::getCellName $design ]
#	puts [db::listAttrs -of $design]
	set libName [db::getAttr libName -of $design]
	set cellName [db::getAttr cellName -of $design]
	puts $LOG "Adding pins to $libName/$cellName"
	puts "Adding pins to $libName/$cellName"
	
	#	puts [db::listAttrs -of $design]
	
	##  Use labels to determine pins.  Actually, for stdcells, only pins should have a pin attribute anyway.
	## This isn't reliable.
	set labels [db::getShapes -of $design -filter %type=="AttrDisplay" ]
	db::foreach label $labels {
	    set name [db::getAttr text -of $label]
	    set pinNames($name) 0
	    #	    puts "Info:  Adding pin $name"
	}
	
	## Cut M0 shapes thru M0-cut layer, need for T5 technode :{"CM0A" "drawing"} {"CM0B" "drawing"} and SS4 : {"X1" "drawing"}
	alphaAddPins_CutMetal $design [list {"CM0A" "drawing"} {"CM0B" "drawing"} {"X1" "drawing"}]
	
	##  Assign pin label info to shapes.
	le::createPinsFromText -design $design
	de::save $ctx
	set design [db::getAttr editDesign -of $ctx]
	
	set shapes [db::getShapes -of $design]
	db::foreach shape $shapes {
	    set type [db::getAttr type -of $shape]
	    ##  Polygon Attributes:    LPP bBox color colorLock connectivityAnchor constraintGroup design figGroupMem groupLeaders groupMems groupsOwnedBy inst layerNum net numPoints orthogonal pin points props purposeNum routeStatus routeType shape shieldedNet1 shieldedNet2 this type unshielded
	    #	    if {$type == "Polygon"} {
	    #		puts "polygon"
	    #		set numPoints [db::getAttr numPoints -of $shape]
	    #		set points [db::getAttr points -of $shape]
	    #		puts "Polygon:  $numPoints, {$points}"
	    #		puts [db::listAttrs -of $shape]
	    # }
	    #	    puts ">>>  $type $LPP"
	    #	    puts "$type: [db::listAttrs -of $shape]"
	    if {($type == "Rect")||($type == "Polygon") } {
		set pin [db::getAttr pin -of $shape]
		if {$pin != ""} {
		    #puts "##1##"
		    ## accessDir constraintGroup design figs groupLeaders groupMems groupsOwnedBy inst name pinType placementStatus props shape term this type
		    set LPP [db::getAttr LPP -of $shape]
		    set lpp [db::getAttr lpp -of $LPP]
#		    set term [db::getAttr term -of $pin]
		    #		    set layerNum [db::getAttr layerNum -of $shape]
#		    if {[lindex $lpp 1] != "drawing"} {continue}                    		    		    
		    if {[regexp "drawing|dpl1|dpl2" [lindex $lpp 1]] == 0 } {continue}
		    #puts "[lindex $lpp 0] [lindex $lpp 1]"
		    set pinLpp [list [lindex $lpp 0] pin]
		    set name [db::getAttr name -of $pin]
		    if {$type == "Rect"} {
#			incr pinNames($name)
			set bbox [db::getAttr bBox -of $shape]
			set pinShape [le::createRectangle $bbox -design $design -lpp $pinLpp -net $name]
			puts $LOG "Creating rect pin \"$name\" on {$pinLpp},  $bbox, shape=$pinShape"
			#puts "Creating rect pin \"$name\" on {$pinLpp},  $bbox, shape=$pinShape"
			if [catch {le::createPin $name -term $name -shapes $pinShape}] {
			    puts $LOG "Error:  le::createPin failed"
			    puts  "Error:  le::createPin failed"
			}
		    } elseif {$type == "Polygon"} {
			set numPoints [db::getAttr numPoints -of $shape]
			set points [db::getAttr points -of $shape]
			set pinShape [le::createPolygon $points -design $design -lpp $pinLpp -net $name]
			puts $LOG "Creating poly pin \"$name\" on {$pinLpp},  $points, shape=$pinShape"
			puts "Creating poly pin \"$name\" on {$pinLpp},  $points, shape=$pinShape"
			if [catch {le::createPin $name -term $name -shapes $pinShape}] {
			    puts $LOG "Error:  le::createPin failed"
			    puts  "Error:  le::createPin failed"
			}
		    }
		}
	    }
	}


	##  Check to make sure all labels had associated geometries
#	foreach name [array names pinNames] {
#	    if {$pinNames($name) == 1} {
#		continue
#	    } elseif {$pinNames($name) == 0} {
#		puts $LOG "Error: No geometries found for pin \"$name\""
#	    } else {
#		puts $LOG "Info: $pinNames($name) geometries found for pin \"$name\""
#	    }
#	}

        # Create object pr-Boundary. Request from R&D for proper cell abutment
	#
	set shapes [db::getShapes -of $design  -lpp {"BOUNDARY" "placement"} ]
	if { [db::getCount $shapes]==0 } {
	  set shapes [db::getShapes -of $design  -lpp {"prBoundary" "boundary"} ]
	}
	if { [db::getCount $shapes]==0 } {
	   set ErrMessage "Error:  No lpp \"BOUNDARY:placement\" or \"prBoundary:boundary\" in the cell"
	   puts $LOG $ErrMessage
	   puts $ErrMessage
	} else {
	   set cellBoundary [db::getNext $shapes]	
	   le::createBoundary [db::getAttr bBox -of $cellBoundary] -design $design -type pr
	}
	de::save $ctx
	de::close $ctx
	return
    }
    
    proc ThereAreLockedCellViewsInLib {libName viewName ignoreCellList} {
	global MSIP_CURRENT_LOG_FILE_POINTER
	global MSIP_LIST_OF_LOCKED_CELL_VIEWS
	global MSIP_LIST_OF_OPEN_CONTEXTS
	###
	if {![info exists MSIP_CURRENT_LOG_FILE_POINTER]} {
	    set MSIP_CURRENT_LOG_FILE_POINTER stdout
	}
	set cells [dm::getCells "*" -libName $libName]
	puts $MSIP_CURRENT_LOG_FILE_POINTER "Info: Count of cells in the library=[db::getCount $cells]"
	puts $MSIP_CURRENT_LOG_FILE_POINTER "Info: Count of ignore cells=[llength $ignoreCellList]"
	###
	set MSIP_LIST_OF_LOCKED_CELL_VIEWS {}
	set MSIP_LIST_OF_OPEN_CONTEXTS {}
	
	###
	db::foreach cell $cells {
	    ###Chek ignore cells ###
	    set cellName [db::getAttr name -of $cell]
	    if {[lsearch -exact $ignoreCellList $cellName ] != -1}  {
		puts $MSIP_CURRENT_LOG_FILE_POINTER "Info: Ignoring cell $cellName"
		continue
	    }
	    set cellView [dm::getCellViews $viewName -cell $cell]
	    ###if cellview exists###
	    if { [db::getCount $cellView] == 1 } {
		###Open/Lock cellview and keep open contexts
		if {[catch {de::open $cellView -headless true} ctx ] } {
		    puts $MSIP_CURRENT_LOG_FILE_POINTER  "Error: Couldn't open/lock $libName:$cellName:$viewName : $ctx\n"
		    lappend MSIP_LIST_OF_LOCKED_CELL_VIEWS "$libName:$cellName:$viewName"
		} else {
		    lappend  MSIP_LIST_OF_OPEN_CONTEXTS $ctx
		}
	    } else {
		if {[db::getCount $cellView] > 1} {
		    puts $MSIP_CURRENT_LOG_FILE_POINTER "Error: There are more than 1 cell views with same name <$viewName> in the <$cellName> cell.\n"
		    return
		}
	    }
	}
	###
	if {[llength $MSIP_LIST_OF_LOCKED_CELL_VIEWS]>0} {
	    return 1
	} else {
	    return 0
	}
	
    }; #End of ThereAreLockedCellViewsInLib
    
    proc ReadIgnoreCellListFile {inFileName} {
	global MSIP_CURRENT_LOG_FILE_POINTER
	if {![info exists MSIP_CURRENT_LOG_FILE_POINTER]} {
	    set MSIP_CURRENT_LOG_FILE_POINTER stdout
	}
	### Read file to list###
	if {[catch  { open $inFileName r } IN_FILE]} {
    	    puts $MSIP_CURRENT_LOG_FILE_POINTER "Error: Couldn't open <$inFileName> file!\n"
    	    return
	}	
	set lstLines [split [read $IN_FILE] \n]
	close $IN_FILE
	###Make unique list###
	array set cellsArray {}
	foreach line $lstLines {
	    set lstWords [split $line]
	    foreach word $lstWords {
		if {$word !=""} {
		    set cellsArray($word) $word
		}
	    }
	}
	return [array names cellsArray]
    }; #End of ReadIgnoreCellListFile
    proc UnsetGlobals {} {
	global MSIP_LIST_OF_OPEN_CONTEXTS
	global MSIP_CURRENT_CONTEXT
	global MSIP_LIST_OF_LOCKED_CELL_VIEWS
	###
	if {[info exists MSIP_LIST_OF_OPEN_CONTEXTS]} {
	    unset MSIP_LIST_OF_OPEN_CONTEXTS
	}
	if {[info exists MSIP_CURRENT_CONTEXT]} {
	    unset MSIP_CURRENT_CONTEXT
	}
	if {[info exists MSIP_LIST_OF_LOCKED_CELL_VIEWS]} {
	    unset MSIP_LIST_OF_LOCKED_CELL_VIEWS
	}
	
	
	
    }

  # Larissa, June 04 2019
  # Added code for changing names of transistors in schematic with "#2f" , like MN1#2f1 -> MN1Dot1
  # These names create issue with verilog and we need to aviod it
  
  proc inst_name_Update {libName cellName viewName } {
       set cv    [dm::findCellView $viewName -cellName $cellName -libName $libName]
       
       set ctx [de::open $cv -headless true -readOnly false]
       set oaDes [db::getAttr editDesign -of $ctx]

       db::foreach inst [db::getInsts -of $oaDes] {
	  
          set instName    [db::getAttr cellName -of $inst]
          set instLibName [db::getAttr libName -of $inst]
          set instId [db::getAttr name -of $inst]
          if {  [regexp {#2f} $instId]} {
	     set newinstId [regsub "#2f" $instId "Dot"]
	     db::setAttr name -of $inst -value $newinstId
	     puts "$instId  => $newinstId"
	  }  


       }       
       de::save  $oaDes
       oa::close $oaDes
       de::close $ctx
       
  }
 
 proc alphaAddPins_CutMetal {design listOfCutLPPs} {
    
    foreach lpp $listOfCutLPPs {
       set cuts [db::getShapes -of $design -lpp $lpp ]  
       if { [db::getCount $cuts] } { le::move $cuts -dx 0.0 -dy 0.0}
    }
 }
  
  proc inst_name_Update_ForLib {libName args} {
     set cells {}
     set cellist [lindex $args 0]
     
     if { $cellist == ""} { 
        set cells [db::createList [dm::getCells -libName  $libName]]
     } else {
        if [catch {open $cellist r} FILE] {
	    puts "Cannot open $cellist for read: $FILE"
	} else {
	    while {[gets $FILE line] >= 0} {
	       set cellName [lindex [split $line] 0]
	       if [catch {set cell [dm::findCell $cellName -libName $libName] } error] {
	          puts "$error"
	       } else {	  
	          #puts $cell
	          lappend cells $cell
	       }	   
	    }
	    close $FILE
	}
     }
     
     foreach acell $cells {
       set cellName [db::getAttr name -of $acell]
       #set cell [dm::findCell $cellName -libName $libName]
       set views [dm::getCellViews -cell $acell]
       db::foreach view $views {
	    set viewName [db::getAttr name -of $view] 
	    
	    if { [regexp {^schematic} $viewName] } {
	       puts "Looking for illegal instance names in $cellName/$viewName"
               inst_name_Update $libName $cellName $viewName 
	    }
       }
     }
  
  }

}
#Creating arguments for the  commnad alpha::AddStdcellPins 
set args [list]
lappend args [de::createArgument -libName  	  -optional false   -description "Library Name"]
lappend args [de::createArgument -viewName 	  -optional true    -description "View Name. Default is layout" -default layout]
lappend args [de::createArgument -headlessMode    -optional true    -description "Open cells in headless mode(true|false). Default is true" -default true]
lappend args [de::createArgument -ignoreCellsFile -optional true    -description "File with ignore cell names" -default "" ]

#Registering Custom Designe TCL command
de::createCommand alpha::addStdcellPins  -category layout -arguments $args -description "Opens each cell of library, initializes the MSIP_CURRENT_CONTEXT global variable, creates pins"




################################################################################
# No Linting Area
################################################################################
# nolint Main
# nolint Line 113: W Found constant "MSIP_CURRENT_CONTEXT" which is also a variable.
# nolint Line 134: W Found constant "cellName" which is also a variable.
#nolint  Line 142: N Unescaped quote

#!/depot/perl-5.14.2/bin/perl
##
## Created by John Sheridan Fisher, 2019-01-04
## Maintained by jsf, 2019-01-04
##
## To-Do:
##
## History:
##  001 ljames  10/25/2022
##      Issue-343  clean up lint errors
##

use strict;
use warnings;

use Capture::Tiny qw/capture/;
use File::Basename qw(dirname basename);
use Getopt::Long;
use File::Copy;
use File::Basename;
use Cwd;
use Cwd 'abs_path';
use POSIX qw(strftime);
use FindBin qw($RealBin $RealScript);

use lib "$RealBin/../lib/perl/";
use Util::CommonHeader;
use Util::Misc;
use Util::Messaging;

#--------------------------------------------------------------------#
our $STDOUT_LOG; # Initiailized in the BEGIN block
our $DEBUG        = NONE;
our $VERBOSITY    = NONE;
our $PROGRAM_NAME = $RealScript;
our $LOGFILENAME  = getcwd() . "/$PROGRAM_NAME.log";
our $VERSION      = get_release_version() || '2022.11';
#--------------------------------------------------------------------#

BEGIN {
    our $AUTHOR='fisher juliano';
    #$STDOUT_LOG  = undef;     # undef       : Log msg to var => OFF
    $STDOUT_LOG   = EMPTY_STR; # Empty String: Log msg to var => ON
    header();
}
&Main()  unless caller();
END {
   footer();
   write_stdout_log( $LOGFILENAME );
   local $?;   # to prevent the exit() status from getting modified
}

sub Main(){
    ## get specified args
    my($success, $help, $overwrite, $debugLine, $checkOnly);
    my($opt_nousage);

    $success = GetOptions(
        "help!"        => \$help,
        "overwrite!"   => \$overwrite,
        "debugLine:s"  => \$debugLine,
        "checkOnly:s"  => \$checkOnly,
        "nousage"      => \$opt_nousage,
        );

    ## quit with usage message, if usage not satisfied
    &usage(0) if $help;
    &usage(1) if ($success != 1);
    &usage(1) if ($#ARGV != 1);

    unless( $opt_nousage || $main::DEBUG ) {
        utils__script_usage_statistics( $RealScript, "2022.11");
    }

    ## local variables
    my($prewaiverRulesFile, $reportsPath, $scriptFile, $checkName, $prewaiverRegex, %prewaiverRegexs, @reportFiles);
    my($reportFile, $origReportFile, $prewaiverFile, $prewaiverLine, @prewaiverLines, $lineContinuation);
    my(@errorLines, $errorLineFlat, $debugLineLine, $state, %cntPrewaiveds, %cntUnwaiveds, %cntSkips, $date);

    ## grab input variables
    $prewaiverRulesFile = "/remote/cad-rep/projects/$ARGV[0]/design/cck/prewaive.txt";
    $reportsPath = abs_path($ARGV[1]);
    $scriptFile = basename($0);

    ## read prewaivers
    print "  Reading $prewaiverRulesFile prewaivers rules file";
    my @wfh_contents = read_file( $prewaiverRulesFile, "I/O ERROR: Failed to open project prewaiver rules file $prewaiverRulesFile" );

#    open(WFH, $prewaiverRulesFile) || die "\nI/O ERROR: Failed to open project prewaiver rules file $prewaiverRulesFile: $!\n";
    foreach my $line (@wfh_contents){
        ## prepend any line continuation
        if(defined $lineContinuation){
            $line = $lineContinuation.$line;
            undef $lineContinuation;
        }
        ## prune comments
        $line =~ s/\s+\#.*//;
        $line =~ s/^\#.*//;
        ## ignore empty lines
        if($line =~ m/^\s*$/){
        }
        ## store any line continuation
        elsif($line =~ s/\s+\&\s*$/\n/){
        $lineContinuation = $line;
        }
        ## identify legal regex
        elsif($line =~ m/^(\S+)\s*\=\~\s*(s\/.*\/.*\/.?\;)$/s){
        ## if regex matches, set a flag
        $prewaiverRegexs{$1}->[($#{$prewaiverRegexs{$1}}+1)] = "\$errorLineFlat \=\~ $2";
        print '.';
        }
        ## fail for unexpected lines
        else{
        print "\nERROR: prewaivers are expected to be 'checkName =~ s/regexPattern/PREWAIVER/;' but regex line in $prewaiverRulesFile prewaiver rules file is:\n$line\n";
        exit 1;
        }
    }
#    close(WFH);
    print "\n";

    ## find and loop through reports
    ##  only grab single check for debug mode
    if(defined $checkOnly){
        @reportFiles = ("$reportsPath/$checkOnly.rpt");
        print "  Note: Only checking $reportsPath/$checkOnly.rpt check...\n";
    }
    else{
        @reportFiles = glob("$reportsPath/*.rpt");
    }
    foreach my $reportFile (sort @reportFiles){
        ## grab check name from report file name
        $checkName = basename($reportFile);
        $checkName =~ s/\.rpt$//;
        ## generate original/back-up report file name
        $origReportFile = $reportFile.'.orig';
        $prewaiverFile = $reportFile.'_prewaive';
        ## parse report file, if it exists
        if(exists $prewaiverRegexs{$checkName}){
            print "  Reading ".basename($reportFile)." report file...\n";
            ## back-up report file to orig file, unless it exists
            if((!-e $origReportFile) && (!defined $overwrite)){
                print "    Copying ".basename($reportFile)." file to ".basename($origReportFile)." file...\n";
                copy $reportFile, $origReportFile || die "Copy $reportFile, $origReportFile failed: $:\n";
            }
            else{
                print "    The ".basename($origReportFile)." original CCK GUI report file exists already (and no -overwrite option). Skipping copy.\n";
            }
            ## read the back-up/orig report file and trimmed report file
    #        open(OFH, $origReportFile) || die "\nI/O ERROR: Failed to open original CCK GUI report file $origReportFile: $!\n";
            my @OFHreport = read_file($origReportFile, "I/O ERROR: Failed to open original CCK GUI report file $origReportFile");
            #open(my $RFH, ">", $reportFile) || die "\nI/O ERROR: Failed to open CCK GUI report file $reportFile: $!\n";
            my @RFHoutput;
            print "    Processing ".basename($origReportFile)." original CCK GUI report file: ";
            ## reset state
            $state = 'idle';
            ## reset prewaiver/unwaived counter
            $cntPrewaiveds{$checkName} = 0;
            $cntUnwaiveds{$checkName}  = 0;

            foreach (@OFHreport){
                ## new device/node/path item
                if((/^(Dev|Node|Path)\s+(\#\d+)\:\s*(\S+)/) || (/^(Path)\s+(\#\d+)\s+starts\s+at\:\s*(\S+)/)){
                    if($state ne 'idle'){
                        die "\nERROR: New error line occured without empty line, which is not supported. Please see the lazy coder...\n";
                    }
                    $prewaiverLine = "$2 $3 waived \"pre-waived by $scriptFile with ";
                    push @errorLines, $_;
                    $state = 'item';
                }
                ## empty lines expected between items to process
                elsif(/^\s*$/){
                    ## if was in an item, process it
                    if($state eq 'item'){
                        ## flatten into a single line for regex eval
                        $errorLineFlat = join '', @errorLines;
                        $errorLineFlat =~ s/[\n\r]+/\n/g;
                        if((defined $debugLine) && ($errorLineFlat =~ /^$debugLine/)){
                            $debugLineLine = 1
                        }else{
                            $debugLineLine = 0;
                        }

                        ## apply prewaiver
                        ##   DEBUGLINE mode allows dumping error after each prewaiver is applied
                        if($debugLineLine == 1){
                            print "\nDEBUGLINE: $errorLineFlat\n";
                        }
                        foreach my $prewaiverRegex (@{$prewaiverRegexs{$checkName}}){
                            ## actually apply an individual prewaiver regex
                            eval($prewaiverRegex); ## no critic qw(BuiltinFunctions::ProhibitStringyEval)
                            ## enable debugLine to see result
                            if($debugLineLine == 1){
                                print "DEBUGLINE:   $prewaiverRegex\nDEBUGLINE: $errorLineFlat\n";
                            }
                        }

                        ## if prewaivers changed the error line, add prewaiver to list for prewaiver file,
                        ##   and note the waived line but do NOT write the error to the updated error file
                        if($errorLineFlat =~ /^PREWAIVER\: /){
                        push @prewaiverLines, $prewaiverLine."$errorLineFlat\"\n";
                        print '+';
                        $cntPrewaiveds{$checkName}++;
                        }
                        ## otherwise, write the error to the updated error file and not the unwaived line
                        else{
                            push(@RFHoutput, @errorLines, '.');
                            #print $RFH @errorLines,"\n";
                            #print '.';
                            $cntUnwaiveds{$checkName}++;
                        }
                        ## reset for next item
                        undef @errorLines;
                        $state = 'idle';
                    }else{
                        ## retain empty lines
                        #print $RFH;
                        push(@RFHoutput, $_);
                    }
                }
                ## other item lines need to be stored
                elsif($state eq 'item'){
                    push @errorLines, $_;
                }
                ## directly dump all other lines
                else{
                    #print $RFH;
                    push(@RFHoutput, $_);
                }
            } ## end  while(<OFH>)
            ## close back-up/orig report file
            #close(OFH);
            #close($RFH);
            write_file(\@RFHoutput, $reportFile);
            #print "\n";
        } ## end  if(exists $prewaiverRegexs{$checkName})
        else{
            print "  NOTE: no prewaivers known for $checkName check. Skipping reading ".basename($reportFile)." report file. Skipping.\n";
            $cntSkips{$checkName} = 1;
        } ## end  else  if(exists $prewaiverRegexs{$checkName})

        ## write prewavier file, if prewaivers exist
        if($#prewaiverLines >= 0){
            $date = strftime "%a %b %e %H:%M:%S %Y", localtime;
            my @RFHdata;
            push( @RFHdata, "[Header]");
            push( @RFHdata, "Time      \: $date");
            push( @RFHdata, "Username  \: $ENV{'USER'}");
            push( @RFHdata, "Error File\: $reportFile\n");
            push( @RFHdata, "[Results]");
            push( @RFHdata, @prewaiverLines);
            write_file( \@RFHdata, $prewaiverFile );
            undef @prewaiverLines;
        }
    } ## end  foreach $reportFile (sort @reportFiles)

    ## summarize unwaived/prewaived counts
    print "  Summary of skipped/unwaived/prewaived errors:\n";
    foreach my $checkName (sort keys %cntUnwaiveds){
        print "\tUnwaived = $cntUnwaiveds{$checkName} and prewaived = $cntPrewaiveds{$checkName} for check $checkName.\n";
    } ## end  foreach $reportFile (sort @reportFiles)
    print("  To check remaining errors, run:\n".
          "\tgrep -cP '^(Path|Node|Dev) #\\d+(:| )' $reportsPath/*.rpt | grep -v :0 > $reportsPath/tmp.txt\n");

    ## All done
    print "All done.\n";

    exit(0);  #  0 == success
} # end of Main

## script usage message
sub usage($) {
    my $exit_status = shift;
    print << "EOP" ;
Description
  A script to pre-waive CCK GUI errors from the CCK GUI reports path:
    /u/$ENV{USER}/scratch/cck/<project_type>/<project>/<libName>/<cellName>/verification_results/reports/check##_name.rpt
  Based on regex prewaivers in project file
    /remote/cad-rep/projects/<project_type>/<project>/<CD_rel>/design/cck/prewaive.txt

  Pre-waiver regex rules:
  - Regex lines can be used as intermediate transformational steps or pre-waiver steps. 
  - Pre-waiver lines must cause the substituted line to start with 'PREWAIVER: '
  - Regex lines can optionally span multiple lines for readability. 
    - Each regex to span to the next line must end with space then amperstand ' &', which will be treated as a new line '\\n' in the regex

  Error file processing
  - Each Path|Node|Dev entry set in the error file must be followed by a blank line. The blank line is the indication of the end of the section.

USAGE : $0 [options] <project_type>/<project>/<CD_rel> <cckGuiReportsPath>

command line options:
-help             print this screen
-overwrite        re-copy *.rpt files to *.rpt.orig files
-debugLine (Path|Node|Dev) #XXX   optional debug command to dump the each prewaiver line processing of a single error  
-checkOnly CckCheckName          optional debug command to only prewaive single CCK check

Assumptions:

EOP
exit($exit_status) ;
}

1; # required if we ever want to run unit tests for this code

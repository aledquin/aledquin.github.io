#!/depot/perl-5.14.2/bin/perl 
###############################################################################
#
# Name    : alphaHLDepotDefRelease
# Author  : John Fisher, Ahmed Hesham(ahmedhes)
# Date    : 2015-04-28
# Purpose : A script to copy def views from the project design directory to the
#           depot release path
#
# Modification History
#     000 John Sheridan Fisher, 2015-04-28
#         Created this script
#     001 Ahmed Hesham(ahmedhes), 2022-04-21
#         Refactored this script
#     
###############################################################################
use strict;
use warnings;
use Getopt::Long;
use File::Copy;
use File::Basename;
use File::Path;
use Cwd;
use Cwd 'abs_path';
use Date::Parse; 
use Date::Manip;
use Term::ANSIColor;

use Capture::Tiny qw/capture/;
use File::Basename qw(dirname basename);
use FindBin qw($RealBin $RealScript);
use lib "$RealBin/../lib/perl/";
use alphaHLDepotRelease;
use Util::CommonHeader;
use Util::Misc;
use Util::Messaging;

#--------------------------------------------------------------------#
our $STDOUT_LOG; # Initiailized in the BEGIN block
our $DEBUG               = NONE;
our $VERBOSITY           = NONE;
our $TESTMODE            = undef;
our $PROGRAM_NAME        = $RealScript;
our $LOGFILENAME         = getcwd() . "/$PROGRAM_NAME.log";
our $VERSION             = get_release_version() || '2022.11'; 
our $AUTO_APPEND_NEWLINE = 1;
 
#------------------------------------------------------------------------------
# Global Vars
#------------------------------------------------------------------------------
my $p4LogFile     = "$PROGRAM_NAME.p4";

BEGIN {
    our $AUTHOR='jfisher, juliano, ahmedhes';
    #$STDOUT_LOG  = undef;     # undef       : Log msg to var => OFF
    $STDOUT_LOG   = EMPTY_STR; # Empty String: Log msg to var => ON
    header();
}
#Capture warning by perl and print them in a warning format to make finding them easier
local $SIG{__WARN__} = sub{
   my $msg = shift;
   wprint($msg);
};
Main();
END {
    local $?;   ## adding this will pass the status of failure if the script
                ## does not compile; otherwise this will always return 0
    footer();
    write_stdout_log("$LOGFILENAME");
}

#-------------------------------------------------------------------------------
sub Main {

   # Process the arguments passed to the script
   my @orig_argv = @ARGV; # save cmd line args because 'process_cmd_line_arg' modifies @ARGV
   
   my ( $opt_projSPEC, $opt_dryrun, $opt_nousage, $opt_p4ws ) = process_cmd_line_args();
   $opt_p4ws = 'p4_ws' unless( defined $opt_p4ws );

   # A call to the usage statistics
   unless( defined($opt_dryrun) || $DEBUG || $opt_nousage ){
      utils__script_usage_statistics( $PROGRAM_NAME, $VERSION, \@orig_argv );
   }

   ## Welcome
   iprint( "Attempting to copy def files for all IPs for $opt_projSPEC\n" );
   iprint( "Writing '$PROGRAM_NAME.log' log file...\n" );

   my ($projType, $proj, $pcsRel) =  parse_project_spec( $opt_projSPEC, \&usage );
   my $projPathAbs   = "/remote/cad-rep/projects/$projType/$proj/$pcsRel";

   my @projRelFiles;
   push (@projRelFiles, "$ENV{DDR_DA_MAIN}/tests/data/$RealScript/$projType.$proj.$pcsRel.legalRelease.yml") if ( defined $ENV{DDR_DA_MAIN} );
   push (@projRelFiles, "$ENV{DDR_DA_MAIN}/tests/data/$RealScript/$projType.$proj.$pcsRel.legalRelease.txt") if ( defined $ENV{DDR_DA_MAIN} );
   push (@projRelFiles, "$projPathAbs/design/legalRelease.yml");
   push (@projRelFiles, "$projPathAbs/design/legalRelease.txt");
   push (@projRelFiles, "$projPathAbs/design_unrestricted/legalRelease.yml");
   push (@projRelFiles, "$projPathAbs/design_unrestricted/legalRelease.txt");
   my $fname_projRelFile = firstAvailableFile(@projRelFiles);
   
   ## setup p4 log file
   iprint( "Setup log file to capture perforce commands issued during this run: '$p4LogFile'\n" );
   my $cmd = "echo '##output of p4 commands' > $p4LogFile";
   run_system_cmd( $cmd, $VERBOSITY );

   my ( %legalRelease );
   # Call process_project_release_file that reads the project legal release file 
   # for the project and do some processing using the items read.
   processLegalReleaseFile($fname_projRelFile, \%legalRelease);
   
   my ( @defCells, @defMacs );
   ## set def macro cells if any
   if( defined $legalRelease{'releaseDefMacro'} ){
      my @splitDefs = split(/\s+/,$legalRelease{'releaseDefMacro'});
      foreach my $eachDef (@splitDefs) {
         my ($defMacro, $defCell) = split(/\//,$eachDef);
         push(@defCells, $defCell);
         push(@defMacs, $defMacro);
      }
   }else{
      fatal_error( "'releaseDefMacro' variable not found in '$fname_projRelFile'. ".
              "Nothing to release\n" );
   }
   
   my ( $relPathAbs, $defPath ) = set_release_path($projPathAbs, \%legalRelease, $opt_p4ws );
   
   my @missingFiles;
   ## loop through macros
   foreach my $macro (@defCells){
      iprint("Copying files for $macro macro...\n");
      my $sourceDEF = "$defPath/$macro.def";
      my $relFile = "$relPathAbs/floorplans/$legalRelease{'rel'}/$macro.def";
      ## check for macro release sync
      unless( -e "${relPathAbs}/floorplans/$legalRelease{'rel'}" ){
         fatal_error( "Macro release path '${relPathAbs}/floorplans/$legalRelease{'rel'}' does not exist.\n".
                 "    Please ensure that the circuit lead has seeded the depot for this macro, ".
                  "then sync for this release:\n".
                 "\tp4 sync ${relPathAbs}/floorplans/$legalRelease{'rel'}/...\n" );
      }

      ## Check existence of def files
      if( !-e $relFile ){
         wprint( "Release file '$relFile' does not exist (must be seeded in p4 depot first), ".
                 "so skipping copy...\n" );
      }elsif( -z $sourceDEF ){
         wprint( "Zero size for '$sourceDEF' file, so skipping copy...\n" );
         push(@missingFiles, $sourceDEF);
      }elsif( !-e $sourceDEF ){
         wprint( "Could not find DEF '$sourceDEF' file, so skipping copy...\n");
         push(@missingFiles, $sourceDEF);
      }else{
         viprint(LOW, "\tCheck-out '$relFile' P4 file\n");
         $cmd = "p4 edit $relFile |& cat >> $p4LogFile";
         unless( defined $opt_dryrun ){
            run_system_cmd( $cmd, $VERBOSITY );
         }else{
            viprint(LOW, "\tNo p4 changes or file conversion steps occur in DEBUG mode\n");
         }
         unless( defined $opt_dryrun ){
            viprint(LOW, "\tGenerating file \n\t\t'$relFile' \n\t\tfrom '$sourceDEF'\n");
            da_copy( $sourceDEF, $relFile ) || confess( "Failed to copy '$sourceDEF'".
                                                        " to '$relFile': $!\n" );
         }else{
            viprint(LOW,"No p4 changes or file conversion steps occur in DEBUG mode\n"); 
         }
      }
      ## p4 opened file
      viprint(LOW, "list opened P4 files\n");
      $cmd = "p4 opened ${relPathAbs}/floorplans/$legalRelease{'rel'}/... |& cat >> $p4LogFile";
      run_system_cmd( $cmd, $VERBOSITY );
   } ## end foreach $macro (@defCells)

   ## All done
   iprint("All done.\n");
   
   print_p4_submit_command($relPathAbs, $opt_dryrun, \%legalRelease);
   
   print_warnings(\@missingFiles);
   # End of Main
}


#-------------------------------------------------------------------------------
sub process_cmd_line_args(){      
    my ( $opt_dryrun,  $opt_verbosity, $opt_debug, $opt_help, 
         $opt_nousage, $opt_projSPEC, $opt_p4ws );
   
    my $success = GetOptions(
         "help!"        => \$opt_help,
         "p=s"          => \$opt_projSPEC,
         "p4ws=s"       => \$opt_p4ws,
         "dryrun!"      => \$opt_dryrun,
         "nousage"      => \$opt_nousage,
         "testmode"     => \$TESTMODE,
         "verbosity=i"  => \$opt_verbosity,
         "debug=i"      => \$opt_debug,
    );

    #
    # Note: -testmode option is basically equivalent to -dryrun in this script.
    # -testmode is the standard way of doing a dry-run; this is used with all the other
    # ddr-ckt-rel scripts.
    #
    if( defined( $TESTMODE )) {
        $opt_dryrun = 1;
    }

    $main::VERBOSITY = $opt_verbosity if( defined $opt_verbosity );
    $main::DEBUG     = $opt_debug     if( defined $opt_debug     );
    $main::TESTMODE  = 1              if( defined $opt_dryrun    );

    ## quit with usage message, if usage not satisfied
    &usage(0) if $opt_help;
    &usage(1) unless( $success );
    &usage(1) unless( defined $opt_projSPEC );
   
   return( $opt_projSPEC, $opt_dryrun, $opt_nousage, $opt_p4ws );
   # End of process_cmd_line_args
}

#-------------------------------------------------------------------------------
sub usage($){
    my $exit_stat = shift;
    if ( ! defined $exit_stat ) {
        $exit_stat = 0;
    }

    print << "EOP" ;
Description
  A script to copy def views from the project design directory struacture
    /remote/cad-rep/projects/<project_type>/<project>/<CD_rel>/design/
  To the depot release path, defined from variables in the project release file:
    /remote/cad-rep/projects/<project_type>/<project>/<CD_rel>/design[_unrestricted]/legalRelease.txt
  These files include:
  - DEF views - copied:
      .../design/floorplans/<rel>/<macro>.def

USAGE : $PROGRAM_NAME [options] -p <project_type>/<project>/<CD_rel>

------------------------------------
Required Args:
------------------------------------
-p  <projSPEC>    project SPEC (i.e. <project_type>/<project>/<CD_rel> )

------------------------------------
Optional Args:
------------------------------------
-help             Print this screen
-p4ws    <arg>    Overrides path to your personal Perforce work area (default: \$HOME/p4_ws)
-dryrun           Do not execute p4 commands (other than status/opened)
-nousage          Do not report usage statistics
-testmode         Same as the -debug option
-verbosity <#>    Set the global VERBOSITY value
-debug     <#>    Set the global DEBUG value

Assumptions:
- Requires that the depot has been seeded (with blank or old files), so that all files exist

EOP
exit ;
}

sub set_release_path($$$){
   print_function_header();
   my $projPathAbs       = shift;
   my $href_legalRelease = shift;
   my $opt_p4ws          = shift;
   
   my $p4client = $ENV{P4CLIENT};
   ## set release path
   my $username = get_username();
   my $relPathBase = "/u/${username}/$opt_p4ws";
   unless( -e $relPathBase ){
      fatal_error("P4 path '$relPathBase' does not exist.\n".
             "    Please ensure that ~/$opt_p4ws is a sym link to the P4 workspace.\n" );
   }
   my $relPath = "$relPathBase/$href_legalRelease->{'p4ReleaseRoot'}/ckt/rel";
   unless( -e $relPath ){
      fatal_error( "Release path '$relPath' does not exist.\n".
              "Please check that this work space 'p4 client' contains\n".
              "\t//depot/$href_legalRelease->{'p4ReleaseRoot'}/... \n".
              "\t//$p4client/$href_legalRelease->{'p4ReleaseRoot'}/...\n");
   }
   my $relPathAbs = abs_path($relPath);
   my $defPath;
   if ( defined $ENV{'DDR_DA_MAIN'} ){
      $defPath = "$ENV{DDR_DA_MAIN}/tests/data/$RealScript/";
   }
   else{
      $defPath    = "$projPathAbs/design/floorplans/$href_legalRelease->{'rel'}";
   }
   
   print_function_footer();
   return ( $relPathAbs, $defPath );
}

sub print_p4_submit_command($$$){
   print_function_header();
   my $relPathAbs        = shift;
   my $debug             = shift;
   my $href_legalRelease = shift;
   
   ## p4 submit command
   if( defined $debug ){
      iprint("DEBUG: No p4 files to submit\n");
   }else{
      p4print( "To complete release deliverables submission to the depot:\n".
               "\tp4 submit -d 'Release $href_legalRelease->{'rel'} DEF views' ".
               "${relPathAbs}/floorplans/$href_legalRelease->{'rel'}/...\n".
               "or\n".
               "\tp4 submit -d 'Release $href_legalRelease->{'rel'} DEF views, updated to fix XYZ' ".
               "${relPathAbs}/floorplans/$href_legalRelease->{'rel'}/...\n");
   }
   
   print_function_footer();
}

sub print_warnings($){
   print_function_header();
   my @missingFiles = @{+shift};
   
   ## warn about any missing files
   if($#missingFiles >= 0){
      eprint( "There were missing source behavioral files:\n\t". join("\n\t",@missingFiles)
              ."\nPlease create the missing source files, or get waivers from the CKT lead.\n" );
   }
   
   print_function_footer();
}

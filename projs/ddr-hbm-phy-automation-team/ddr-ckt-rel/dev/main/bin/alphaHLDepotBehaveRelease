#!/depot/perl-5.14.2/bin/perl -w
###############################################################################
#
# Name    : alphaHLDepotPhyvRelease
# Author  : John Fisher, Ahmed Hesham(ahmedhes)
# Date    : 2015-04-28
# Purpose : This script will copy behavioral views from the project design 
#           structure to the depot. The files include the RTL and the cosim
#           view. The RTL view will be copied and abstracted to the interface
#           file, and is generated for the PHYV macros.
#
# Modification History
#     000 John Sheridan Fisher, 2015-04-28
#         Created this script
#     001 Ahmed Hesham(ahmedhes), 2022-04-21
#         Refactored this script
#     
###############################################################################
use strict;
use warnings;
use Getopt::Long;
use File::Copy;
use File::Basename;
use File::Path;
use Cwd;
use Cwd 'abs_path';
use Date::Parse; 
use Date::Manip;
use Data::Dumper;
$Data::Dumper::Sortkeys = sub { [sort {$b cmp $a} keys %{$_[0]}] };
use POSIX qw(strftime);
use Term::ANSIColor;
use Carp;
use Clone 'clone';
use FindBin qw($RealBin $RealScript);

use lib "$RealBin/../lib/perl/";
use Util::CommonHeader;
use Util::Misc;
use Util::Messaging;
use alphaHLDepotRelease;

#--------------------------------------------------------------------#
our $STDOUT_LOG; # Initiailized in the BEGIN block
our $DEBUG        = NONE;
our $VERBOSITY    = NONE;
our $TESTMODE     = NONE;
our $PROGRAM_NAME = $RealScript;
our $LOGFILENAME  = getcwd() . "/$PROGRAM_NAME.log";
our $VERSION      = get_release_version();
#--------------------------------------------------------------------#

#------------------------------------------------------------------------------
# Global Vars
#------------------------------------------------------------------------------
my $p4LogFile            = "$PROGRAM_NAME.p4";
my $date                 = strftime "%a %b %e %H:%M:%S %Y", localtime;

BEGIN {
    our $AUTHOR='jfsiher, juliano, ahmedhes';
    #$STDOUT_LOG  = undef;     # undef       : Log msg to var => OFF
    $STDOUT_LOG   = EMPTY_STR; # Empty String: Log msg to var => ON
    header();
}
#Capture warning by perl and print them in a warning format to make finding them easier
local $SIG{__WARN__} = sub{
   my $msg = shift;
   wprint($msg);
};
&Main() unless caller() ;
END {
   local $?;   ## adding this will pass the status of failure if the script
               ## does not compile; otherwise this will always return 0
   footer();
   write_stdout_log( $LOGFILENAME );
}

#--------------------------------------------------------------------------
#  Start the MAIN subroutine ... this is where the entire 
#      algo can be found.
#  1. Read topcells.txt, alphaNT.config, legalRelase.txt
#  2. Setup path to the user's P4 disk area
#  3. Get macro list from (1) cmd line, otherwise (2) legalRelease file
#--------------------------------------------------------------------------
sub Main(){
   my @orig_argv = @ARGV; # keep this here cause GetOpts modifies ARGV

   # Process the arguments passed to the script
   #    '$debug'     -> legacy option which avoid writing into P4
   #    '$opt_debug' -> use cmd line switch '-info', used for $DEBUG
   my ( $opt_projSPEC,  $opt_macros, $opt_dryrun, $opt_nousage,
        $opt_cosimUniq, $opt_p4ws ) = process_cmd_line_args();
   
   # A call to the usage statistics
   unless( $DEBUG || $opt_nousage ){
      utils__script_usage_statistics( $PROGRAM_NAME, $VERSION, \@orig_argv );
   }
   
   ## Welcome
   iprint( "Copying behavioral files for all macros in project: '$opt_projSPEC'\n" );
   iprint( "Writing '$PROGRAM_NAME.log' log file...\n" );
   
   my $p4client            = $ENV{P4CLIENT};  # Ex: P4CLIENT=msip_cd_juliano
   my $projPathAbs         = "/remote/cad-rep/projects/$opt_projSPEC";
   my ($projType, $proj, $pcsRel) =  parse_project_spec( $opt_projSPEC, \&usage );

   # Call get_project_file_path to find the first valid location of the input files.
   # Returns NULL_VAL if none of the paths contain the expected file.
   my ( $fname_projMacroFile, 
        $fname_projNtFile,
        $fname_projRelFile,
        $fname_projVerifFile ) = get_project_files_path( $projPathAbs, $projType, $proj, $pcsRel );
   
   ## setup p4 log file 
   iprint( "Setup log file to capture perforce commands issued during this run: '$p4LogFile'\n" );
   my $cmd  = "echo '##output of p4 commands' > $p4LogFile";
   run_system_cmd( $cmd, $VERBOSITY );
   
   # Read the project topcell file to get the list of legal macros
   my %legalMacros = readTopCells( $fname_projMacroFile );
   
   # Read the project NT file to get the corners list
   # read_project_NT_file( $fname_projNtFile, \@corners );

   my ( @corners );
   {
      my ($aref, $href) = readNtFile( $fname_projNtFile );
      @corners = @$aref;
   }
       
   my ( %legalRelease );
   # Call process_project_release_file that reads the project legal release file 
   # for the project and do some processing using the items read.
   processLegalReleaseFile($fname_projRelFile, \%legalRelease);

   #----------------------------------------------------------
   ## Setup path to the user's P4 disk area
   my $username = get_username();
   my $relPathBase = "/u/${username}/p4_ws";
   if( defined $opt_p4ws ){ 
      $relPathBase = "/u/${username}/$opt_p4ws";
   }
   my $relPathAbs = set_release_path( $relPathBase, $p4client, $proj, $projType,
                                      $legalRelease{p4ReleaseRoot} ); 
   my $ctlPath    = "$relPathBase/projects/$projType/$proj/latest/design/ctl";
   
   my ( %pincheckLogFiles, %pincheckDirtys, %pincheckWarnings );
   my ( @missingFiles );

   #----------------------------------------------------------
   #  Get macro list from (1) cmd line, otherwise (2) legalRelease file
   #  Find only those macros that are sync'd already.
   #----------------------------------------------------------
   ## Add releaseShimMacro to the hash of legal macros
   if( exists($legalRelease{'releaseShimMacro'}) ){
      my @fields = split(' ',$legalRelease{'releaseShimMacro'});
      foreach my $field (@fields){
         $legalMacros{$field}++;
      }
   }

   my @macros = check_if_macros_are_legal( \%legalMacros, $opt_macros );
   my @syncd_macros = find_macros_p4_syncd_already( $relPathAbs, $legalRelease{'rel'}, @macros );
      
   #----------------------------------------------------------
   # Find list of metal stacks for each macro, then copy views. 
   #----------------------------------------------------------
   foreach my $macro ( @syncd_macros ){
      ## grab verilog module name from macro name
      my $vmodule = $macro;
      $vmodule =~ s/(_ew|_ns)$//i; ## trim EW/NS suffix

      # check if pincheck files exist and get metal stacks for pincheck files
      # extract the valid metal stacks based on whether the pincheck file exists
      my $p4filepath = "//depot/".$legalRelease{"p4ReleaseRoot"}."/ckt/rel/".$macro."/".$legalRelease{"rel"}."/macro";
      my $pincheckFlowCheck = checkPinCheckExist( "$p4filepath/..." );
      my @allStacks;
      if( $pincheckFlowCheck == FALSE ){
         wprint("No pincheck folder/files found, defaulting to LEGACY flow\n");
         if ($macro =~ /_blocks/){
            push @allStacks, $legalRelease{"metalStack"};
         } elsif ($macro =~ /cover/ || $macro =~ /_tcoil_replica/){
            # P10020416-38355: use metalStackCover for tcoil_replica
            push @allStacks, $legalRelease{"metalStackCover"};
         } else {
            push @allStacks, $legalRelease{"metalStackIp"};
         }
      } elsif( $pincheckFlowCheck == TRUE ){
         wprint( "Pincheck folder and files found for macro '$macro', defaulting to NEW flow\n" );
         my ($stdout, $run_status) = run_system_cmd("p4 sync -f $p4filepath/pincheck/...");
         dprint(HIGH, "P4 sync command return: $stdout");
         if ($stdout !~ m/refreshing/ && $stdout !~ m/up-to-date/ && $stdout !~ m/added/ || $run_status){
               fprint("P4 reported the following error: $stdout");
         }
         @allStacks = da_findSubdirs("$relPathAbs/$macro/".$legalRelease{"rel"}."/macro/pincheck");
      } elsif( $pincheckFlowCheck == NULL_VAL ){
         fatal_error( "File path doesn't exist or invalid:\n\t '$p4filepath'\n" );
      } else {
         fatal_error( "Something went wrong ... unexpected return value from subroutine. Contact $main::AUTHOR\n" );
      }

      # Call create_file_map: creates file map for each macro and points to the pincheck files
      # if the macro is part of the utility or the repeater lists 
      my ( %fileMap, %pincheckFiles );
      my ( $rtlInterface ) = create_file_map($macro, $projPathAbs, $relPathAbs, $ctlPath,
                                             $vmodule, \%legalRelease, \%fileMap, \%pincheckFiles,
                                             $projType, $proj, $pcsRel );
      
      # Call copy_files subroutine to loop through the filemap and copy the release files
      # It also returns a segement to be appended to the pincheck script
      my ($pincheckCmdSegment) = copy_files($macro, $vmodule, $rtlInterface,
                                            $projPathAbs, $opt_cosimUniq, $opt_nousage,
                                            $opt_dryrun, \%legalRelease, \%fileMap,
                                            \@missingFiles, $projType, $proj, $pcsRel );

      if ($pincheckFlowCheck == TRUE){
         foreach my $stack (@allStacks){
            # call run_pincheck_script subroutine that creates the pincheck shell file and calls it
            run_pincheck_script($macro, $stack, $pincheckCmdSegment, $relPathAbs, $vmodule,
                              $projType, $opt_dryrun, \%legalRelease, \%pincheckFiles, 
                              \%pincheckLogFiles, \%pincheckDirtys, \%pincheckWarnings, \@missingFiles);
         }
      } else {
         my $stack = "0";
         # call run_pincheck_script subroutine that creates the pincheck shell file and calls it
            run_pincheck_script($macro, $stack, $pincheckCmdSegment, $relPathAbs, $vmodule,
                              $projType, $opt_dryrun, \%legalRelease, \%pincheckFiles, 
                              \%pincheckLogFiles, \%pincheckDirtys, \%pincheckWarnings, \@missingFiles);
      }
   }
   
   iprint("All done!\n\n");
   
   print_p4_submit_command($legalRelease{'rel'}, $relPathAbs, $opt_dryrun, \@macros);
   
   print_warnings($opt_dryrun, \%pincheckWarnings, \%pincheckDirtys, \%pincheckLogFiles,
                  \@macros, \@missingFiles);
   
   # End of Main
}

#----------------------------------------------------------
#  Find only those macros that are sync'd already.
#----------------------------------------------------------
sub find_macros_p4_syncd_already(@){
   my $relPathAbs = shift;
   my $rel        = shift;
   my @macros = @_;
   
   my @syncd_macros;
   foreach my $macro ( sort @macros ){
      hprint("Copying files for macro...'$macro'\n");

      ## check for existence of the release version for the macro in the P4 WS
      unless( -e "$relPathAbs/$macro/$rel" ){
         eprint( "Macro release path $relPathAbs/$macro/$rel does not exist.\n".
                 "Please ensure that the circuit lead has seeded the depot for this macro, ".
                 "then sync for this release:\n".
                 "\tp4 sync $relPathAbs/$macro/$rel/...\n");
      }
      push(@syncd_macros, $macro)
   }
   return( @syncd_macros );
}

#-------------------------------------------------------------------------------
#  Create a file map for the current macro linking the source file and the
#  release file
#-------------------------------------------------------------------------------
sub create_file_map($$$$$$$$$$$){
   print_function_header();
   my $macro               = shift;
   my $projPathAbs         = shift;
   my $relPathAbs          = shift;
   my $ctlPath             = shift;
   my $vmodule             = shift;
   my $href_legalRelease   = shift;
   my $href_fileMap        = shift;
   my $href_pincheckFiles  = shift;
   my $projType            = shift;
   my $proj                = shift;
   my $pcsRel              = shift;
   
   my ( %filemap, $rtlInterface );
   
   my $projRel = $href_legalRelease->{'rel'};

   ## skip SHIM macros (no behavioral views)
   unless( exists($href_legalRelease->{'shimMacros'}->{$macro}) ){
      my $viewsPath = "$relPathAbs/$macro/$projRel/macro";
      ## if COVER cell
      if( $macro =~ /cover/i ){
         my $hardmacroName = $vmodule =~ s/.*cover_//r;
         my $verilogFile = (glob("$projPathAbs/design/rtl/$projRel/".
                                 "*${hardmacroName}_interface.v"))[0];
         unless( defined($verilogFile) ){
            $verilogFile = "$projPathAbs/design/rtl/$projRel/".
                           "{ending_with}${hardmacroName}_interface.v"
         }
         $href_fileMap->{'verilog'}->{$verilogFile}
                                          = "$viewsPath/interface/${macro}_interface.v";
      }else{
         ## if not COVER cell
         $href_fileMap->{'verilog'}->{"$projPathAbs/design/rtl/$projRel/${vmodule}.v"}
                                          = "$viewsPath/behavior/${macro}.v";
      }
      $rtlInterface = "$viewsPath/interface/${macro}_interface.v";
      my $process   = $href_legalRelease->{'process'};
      $href_fileMap->{'cdl'}->{"$projPathAbs/design/cosim/$projRel/${macro}_$process.sp"} 
                                       = "$viewsPath/cosim/${macro}.sp";
      $href_fileMap->{'cosim'}->{"$projPathAbs/design/cosim/$projRel/corners.inc"} 
                                       = "$viewsPath/cosim/corners.inc";
      $href_fileMap->{'ctl'}->{"$ctlPath/$vmodule/$vmodule.ctl"} 
                                       = "$viewsPath/atpg/ctl/${macro}.ctl";
      ## find where the path to the pin check csv file
      my $filePath;
      if(    (grep{/$macro/} @{$href_legalRelease->{'utilityMacro'}}) 
          || (grep{/$macro/} @{$href_legalRelease->{'repeaterMacro'}}) ){
         ## utility macros need to use project disk pininfo files because not all cells in utility macro will be released
         #-----------------------------
         #  find pininfo CSV files
        my(@csvfiles);
           push(@csvfiles, "$ENV{DDR_DA_MAIN}/tests/data/$RealScript/$projType.$proj.$pcsRel.pininfo.$macro.csv")
                 if( defined $ENV{'DDR_DA_MAIN'} );
           push(@csvfiles, "$projPathAbs/design/pininfo/$projRel/$macro.csv" );
           push(@csvfiles, "$projPathAbs/design_unrestricted/pininfo/$projRel/$macro.csv" );
           $filePath = firstAvailableFile( @csvfiles );
         #-----------------------------
         # If neither of the file exist, use any one to print the error later on
         if( $filePath eq NULL_VAL ){
            $filePath = "${projPathAbs}/design/pininfo/$projRel/$macro.csv";
         }
      }else{
         $filePath = "$relPathAbs/$macro/$projRel/macro/pininfo/$macro.csv";
      }
      $href_pincheckFiles->{$macro}->{$filePath} = 'pinCSV';
   }
   if ( $main::DEBUG >= HIGH){
       dprint(HIGH, "\%fileMap               => ". pretty_print_href($href_fileMap) );
       dprint(HIGH, "\%pincheckFiles{$macro} => ". pretty_print_href($href_pincheckFiles->{$macro}) );
       prompt_before_continue( CRAZY );
   }
   
   print_function_footer();
   return ( $rtlInterface );
   # End of create_file_map
}

#-------------------------------------------------------------------------------
#  Copy the files, generating the interface file, and the rtl file for the phyv
#  macros
#-------------------------------------------------------------------------------
sub copy_files($$$$$$$$$$$$$){
   print_function_header();
   my $macro             = shift;
   my $vmodule           = shift;
   my $rtlInterface      = shift;
   my $projPathAbs       = shift;
   my $opt_cosimUniq     = shift;
   my $opt_nousage       = shift;
   my $opt_dryrun        = shift;
   my $href_legalRelease = shift;
   my $href_fileMap      = shift;
   my $aref_missingFiles = shift;
   my $projType          = shift;
   my $proj              = shift;
   my $pcsRel            = shift;
   
   my ( $cmd, $pincheckCmdSegment );
   
   ## loop through behave types
   foreach my $behaveType (sort keys %{$href_fileMap}){
      ## loop through behave files
      foreach my $behaveFile (sort keys %{$href_fileMap->{$behaveType}}){
         my $relFile = $href_fileMap->{$behaveType}->{$behaveFile};

         ## check rel file exists
         unless( -e $relFile ){
            wprint(  "Release file does not exist "
                    ."(must be seeded in p4 depot first), so skipping copy...\n"
                    ."\t$relFile\n" );
         ## check behave file exists or a phyv macro verilog file since
         #  it's generated from the pininfo file.
         }elsif( !( -e $behaveFile
                 || (exists($href_legalRelease->{'phyvMacros'}->{$macro}) 
                     && ($behaveType eq 'verilog')) ) ){
            wprint( "Source behave file does not exist, so skipping copy...\n"
                   ."\t$behaveFile\n" );
            push(@$aref_missingFiles, $behaveFile);
         ## now copy files, or create PHYV only RTL
         }else{
            ## p4 check out rel file
            viprint(LOW, "\tCheck-out $relFile P4 file\n");
            $cmd = "p4 edit $relFile |& cat >> $p4LogFile";
            unless( defined $opt_dryrun ){
               run_system_cmd( $cmd, $VERBOSITY );
            }else{
               viprint(LOW, "\tNo p4 changes or file conversion steps occur in DEBUG mode\n");
            }

            ## create interface RTL
            if( ($behaveType eq 'verilog') ){
                  # For the covercells, copy the interface file of the hardmacro instead,
                  # don't copy the behavior view.
                  if( $macro =~ /cover/i ){
                     viprint(LOW, "Copying the interface file\n\t$relFile \n".
                                  "\t\tfrom the hardmacro interface file\n\t$behaveFile\n" );
                     copy_covercell_interface($macro, $behaveFile, $relFile, $opt_dryrun);
                  }
                  ## for RTL view on PHYV macros, create the view
                  elsif( exists($href_legalRelease->{'phyvMacros'}->{$macro}) ){
                     viprint(LOW, "Generating RTL view file from pininfo file:\n\t $relFile \n" );
                     create_rtl_view($macro, $relFile, $rtlInterface, $projPathAbs,
                                     $opt_dryrun, $href_legalRelease,
                                     $projType,   $proj, $pcsRel );
                  } 
                  ## otherwise, copy RTL (but make orientation specific)
                  ## and generate interface view
                  else{
                     viprint(LOW, "Generating RTL view \n\t$relFile \n\tfrom RTL\n\t$behaveFile \n" );
                     copy_rtl_view($macro, $vmodule, $behaveFile, $relFile, $rtlInterface,
                                   $opt_nousage, $href_legalRelease, $opt_dryrun);
                  }
            } ## end  if(($behaveType eq 'verilog'))
            elsif( ($behaveType eq 'cdl') && (defined $opt_cosimUniq) ){
               viprint(LOW, "Uniquifying and copying COSIM file\n"
                           ."\t$behaveFile \n"
                           ."\tto $relFile \n" );
               $cmd = "$RealBin/alphaCdlPrep.tcl  -cdlIn $behaveFile  -cdlOut $relFile  ".
                        "-cellName $macro  -forceBracket square  -prepend ${macro}_";
               unless( defined $opt_dryrun ){
                  run_system_cmd( $cmd, $VERBOSITY );
                  unless( -e $relFile ){
                     fatal_error( "CDL prep failed to generate $relFile release CDL file.\n"); 
                  }
                  ## check for zero size files
                  if( -z $relFile ){
                     wprint("After copy, zero file size for release file $relFile"); 
                  }
               }
               else{
                  viprint(LOW, "No p4 changes or file conversion steps occur in DEBUG mode\n");
               }
             ## end elsif(($behaveType eq 'cdl') && (defined $cosimUniq))
            ## Otherwise, just copy the file
            }else{
               viprint(LOW, "Copying file\n\t$behaveFile \n\tto $relFile\n");
               unless( defined $opt_dryrun ){
                  da_copy($behaveFile, $relFile) || confess( "Failed to copy $behaveFile, ".
                                                             "$relFile: $!\n" );
                  ## check for zero size files
                  if( -z $relFile ){
                     wprint("After copy, zero file size for release file $relFile\n");
                  }
               }else{
                  viprint(LOW, "No p4 changes or file conversion steps occur in DEBUG mode\n");
               }
            }

            ## add files to check to pincheck
            if( ($behaveType eq 'verilog') || ($behaveType eq 'cdl') ){
                  ## in TESTMODE mode, use original source files
                  if( defined $opt_dryrun && (-e $behaveFile) ){
                     $pincheckCmdSegment .= "  -$behaveType $behaveFile \\\n";
                  }elsif( defined $opt_dryrun && ($behaveType eq 'verilog') 
                          && exists($href_legalRelease->{'phyvMacros'}->{$macro}) ){
                     ## skip behave views for PHY
                     viprint(LOW, "Verilog views are skipped in pin check for PHYV-only macros, ".
                                  "since the views are not generated in DEBUG mode\n" );
                  }else{
                     $pincheckCmdSegment .= "  -$behaveType $relFile \\\n";
                  }
            }
         } ## end else if(!-e $relFile)
      } ## end foreach $behaveFile (sort keys %{$fileMap{$behaveType}})
   } ## end foreach $behaveType (sort keys %fileMap)
   vhprint(LOW, "Done copying files for $macro macro.\n");
   
   prompt_before_continue( CRAZY );
   print_function_footer();
   return ( $pincheckCmdSegment );
}  # End of copy_files

#-------------------------------------------------------------------------------
#  Copy the rtl file and generate the interface file
#-------------------------------------------------------------------------------
sub copy_rtl_view($$$$$$$$){
   print_function_header();
   my $macro             = shift;
   my $vmodule           = shift;
   my $behaveFile        = shift;
   my $relFile           = shift;
   my $rtlInterface      = shift;
   my $opt_nousage       = shift;
   my $href_legalRelease = shift;
   my $opt_dryrun        = shift;

   if( defined $opt_dryrun ){
      viprint(LOW, "\tNo p4 changes or file conversion steps occur in DEBUG mode\n" );
   }else{
      ## open behevioral RTL verilog file
      my @behaveFileLines = read_file( $behaveFile );
      
      my @lines; 
      ## open behevioral RTL verilog file to change RTL vmodule to macro
      foreach my $line ( @behaveFileLines ){
         $line =~ s/^(\s*module\s+)$vmodule\b/$1$macro/;
         push(@lines, $line);
      }
      ## open RTL verilog file
      write_file( \@lines, $relFile );
   } ## end  else if(defined $opt_dryrun)

   ## p4 check out rel file
   viprint(LOW, "\tCheck-out $rtlInterface P4 file\n");
   my $cmd = "p4 edit $rtlInterface |& cat >> $p4LogFile";
   unless( defined $opt_dryrun ){
      run_system_cmd( $cmd, $VERBOSITY );
   }else{ 
      viprint(LOW, "\tNo p4 changes or file conversion steps occur in DEBUG mode\n");
   }

   ## generate RTL interface file
   $cmd = "$RealBin/alphaHLDepotInterfaceVerilog -release $relFile -rtl $rtlInterface";
   $cmd .= " -nousage" if( $opt_nousage );
   if( exists($href_legalRelease->{'repeaterSubMacros'}->{$macro}) ){
      my $subMacrosList = join(",",@{$href_legalRelease->{'repeaterSubMacros'}->{$macro}});
      $cmd .= " -macros $subMacrosList";
   }
   unless( defined $opt_dryrun ){
      run_system_cmd( $cmd, $VERBOSITY+1 );
      ## check for zero size files
      if( -z $relFile ){
         wprint( "\tAfter copy, zero file size for release file $relFile\n" );
      }
   }else{ 
      viprint(LOW, "\tNo p4 changes or file conversion steps occur in DEBUG mode\n"); 
   } 
   print_function_footer();
}

#-------------------------------------------------------------------------------
#  Copy the hardmacro interface view for the covercells
#-------------------------------------------------------------------------------
sub copy_covercell_interface($$$$){
   print_function_header();
   my $macro             = shift;
   my $interfaceFile     = shift;
   my $relFile           = shift;
   my $opt_dryrun        = shift;

   if( defined $opt_dryrun ){
      viprint(LOW, "\tNo p4 changes or file conversion steps occur in DEBUG mode\n" );
   }else{
      ## open interface RTL verilog file
      my @behaveFileLines = read_file( $interfaceFile );
      
      my @lines;
      
      # Get the hardmacro name from the RTL interface file name
      my $hardmacroName = basename($interfaceFile,"_interface.v");
      # Remove ifdef
      if( (grep{/^`ifdef/} @behaveFileLines) && (grep{!/^`else/} @behaveFileLines) ){ 
         @behaveFileLines = grep{!/^`ifdef|^`endif/} @behaveFileLines;
      }
      ## open interface RTL verilog file to change RTL hardmacro name to macro
      foreach my $line ( @behaveFileLines ){
         $line =~ s/^(\s*module\s+)$hardmacroName\b/$1$macro/;
         push(@lines, $line);
      }
      ## write interface verilog file
      write_file( \@lines, $relFile );
   } ## end  else if(defined $opt_dryrun)

   unless( defined $opt_dryrun ){
      ## check for zero size files
      if( -z $relFile ){
         wprint( "\tAfter copy, zero file size for release file $relFile\n" );
      }
   }else{ 
      viprint(LOW, "\tNo p4 changes or file conversion steps occur in DEBUG mode\n"); 
   } 
   print_function_footer();
}

#-------------------------------------------------------------------------------
#  Create the rtl file and use it for the interface as well
#-------------------------------------------------------------------------------
sub create_rtl_view($$$$$$$$$){
   print_function_header();
   my $macro             = shift;
   my $relFile           = shift;
   my $rtlInterface      = shift;
   my $projPathAbs       = shift;
   my $opt_dryrun        = shift;
   my $href_legalRelease = shift;
   my $projType          = shift;
   my $proj              = shift;
   my $pcsRel            = shift;

   ## reset cell pin list
   my ( %cellPins );
   ## identify pins for the macro (or for each cell in the utility library)
   foreach my $cell (@{$href_legalRelease->{'phyvMacros'}->{$macro}}){
      ## set pininfo file
      next if($cell eq '');
      #-----------------------------
      #  find pininfo CSV files
        my(@csvfiles);
        push(@csvfiles, "$ENV{DDR_DA_MAIN}/tests/data/$RealScript/$projType.$proj.$pcsRel.pininfo.$cell.csv")
                 if( defined $ENV{'DDR_DA_MAIN'} );
        my $pininfo_path = "$projPathAbs/design/pininfo/$href_legalRelease->{'rel'}";
        push(@csvfiles,  "$pininfo_path/$cell.csv" );
        push(@csvfiles,  "$projPathAbs/design_unrestricted/pininfo/$href_legalRelease->{'rel'}/$cell.csv");
        my $fname_pininfo = firstAvailableFile( @csvfiles );
        # If neither of the file exist, use any one to print the error later on
        if( $fname_pininfo eq NULL_VAL ){
           $fname_pininfo = "$pininfo_path/$cell.csv";
        }
      #-----------------------------

      viprint(LOW, "\tReading $fname_pininfo pininfo file...\n");
      ## open pininfo files
      my @pininfoContent =  read_file( $fname_pininfo );
      
      my $pininfoHeader;
      ## grab header and check it is expected
      $pininfoHeader = shift(@pininfoContent);
      chomp $pininfoHeader;
      $pininfoHeader =~ s/\#.*//;
      ## if first header is comment or empty, grab next line
      while($pininfoHeader =~ /^\s*$/){
         $pininfoHeader = shift(@pininfoContent);
         print  "$pininfoHeader\n";
         $pininfoHeader =~ s/\#.*//;
      }
      ## now that comment and empty lines are gone, should have the real header
      if(!$pininfoHeader =~ /^name\,.*\,cell_x_dim_um\,cell_y_dim_um$/i){
         fatal_error( "pininfo file header is not as expected, \n".
                 "which must being with 'name,' and end with ',cell_x_dim_um\,cell_y_dim_um'\n".
                 "\nFound: '$pininfoHeader'\n" );
         ### support random header order
      }
      ## loop through pininfo pins
      my $lineNumber = 0;
      foreach my $line (@pininfoContent){
         $lineNumber++;
         ## find power pins
         if( $line =~ /^([^\,]+)\,.*power/i ){
            $cellPins{$cell}->{'power'}->{$1}++;
         }elsif( $line =~ /^([^\,]+)\,.*ground,.*\,([\d\.]+),([\d\.]+)$/i ){
         ## find ground pins
            $cellPins{$cell}->{'ground'}->{$1}++;
            ## calculate VSS pin area
            if($1 eq 'VSS'){
               $cellPins{$cell}->{'area'} = $2 * $3;
            }
         }elsif( $line =~ /^([\w\_\[\:\]]+)\,([IO]+)\,general_signal\,/i ){
         ## find signal pins ### BOZO: make this hack more general to handle busses
            my $pin = $1;
            my ( $direction );
            ## error trap pin direction
            if($2 eq 'I'){
               $direction = 'input';
            }elsif( $2 eq 'O' ){
               $direction = 'output';
            }elsif( $2 eq 'IO' ){
               $direction = 'inout';
            }else{
               fatal_error( "PHYV-only macro pin directions I, O, and IO, but ".
                       "$fname_pininfo pininfo file contained an unsupported ".
                       "direction $2 in line $lineNumber:\n$_\n" );
            }

            # A bus needs to be reformatted properly. For example, change from
            #    => tech_revision[15:0]
            # to
            #    => wire [15:0] tech_revision
            dprint(HIGH, "Line='$line'\n" );
            if( $pin =~ m|^\w+\[\d+:\d+\]$| ){
               dprint(SUPER, "The pin is a bus => '$pin'\n" );
               $pin =~ s|^(\w+)(\[\d+:\d+\])$|wire $2 $1|;
               dprint(HIGH, "Reformatted bus => '$pin'\n" );
            }
            $cellPins{$cell}->{'signal'}->{$pin}->{'direction'} = $direction;
            dprint(HIGH, "Cell='$cell' <=> Pin='$pin' <=> Dir='$direction'\n" );
            prompt_before_continue(SUPER);
         }else{
         ## flag other pins
            fatal_error( "PHYV-only can only contain power".
                    " pins (i.e. <pinName>,...,primary_power,...)\n ".
                    " or ground pins (i.e. <pinName>,...,primary_power)".
                    " but $fname_pininfo pininfo file contained an unsupported line:\n".
                    "$_\n" );
         }
      } ## end foreach my $line (@pininfoContent)
      ## ensure VSS exists
      unless( exists($cellPins{$cell}->{'ground'}->{'VSS'}) ){
         fatal_error( "PHYV-only are expected to have VSS ground pin, ".
                 "but was not found in pininfo file: '$fname_pininfo'\n" );
      }
   } ## end  foreach $cell (@{$href_legalRelease->{'phyvMacros'}->{$macro}})
   ## open RTL verilog file
   unless( defined $opt_dryrun ){
      my @lines;
      push(@lines, "\/\/ PHYV macro $macro RTL file\n\n" );
      foreach my $cell ( @{$href_legalRelease->{'phyvMacros'}->{$macro}} ){
         push(@lines, "module $cell \(\n" );

         ## write all pins
         my @pin_lines = map{"    input " . $_} ((sort keys %{$cellPins{$cell}->{'power'}}),
                                                (sort keys %{$cellPins{$cell}->{'ground'}}));

         foreach my $pin (sort keys %{$cellPins{$cell}->{'signal'}}){
            push(@pin_lines, "    $cellPins{$cell}->{'signal'}->{$pin}->{'direction'} " . "$pin");
         }

         push(@lines, join(",\n", @pin_lines));
         ## write end module
         push(@lines, "\)\;\nendmodule // $cell\n" );
      }
      ## write RTL verilog file
      write_file( \@lines, $relFile );
   }else{ 
      viprint(LOW, "\tNo p4 changes or file conversion steps occur in DEBUG mode\n"); 
   }

   ## p4 check out rel file
   viprint(LOW, "\tCheck-out $rtlInterface P4 file\n");
   my $cmd = "p4 edit $rtlInterface |& cat >> $p4LogFile";
   unless( defined $opt_dryrun ){
      run_system_cmd( $cmd, $VERBOSITY ); 
   }else{
      viprint(LOW, "\tNo p4 changes or file conversion steps occur in DEBUG mode\n"); 
   }

   ## copy RTL to interface file
   unless( defined $opt_dryrun ){
      da_copy($relFile, $rtlInterface) || confess( "Failed to copy $relFile, ".
                                                   "$rtlInterface: $!\n" );
      ## check for zero size files
      if( -z $rtlInterface ){
         wprint( "\tAfter copy, zero file size for release file $rtlInterface\n" );
      }
   }else{ 
      viprint(LOW, "\tNo p4 changes or file conversion steps occur in DEBUG mode\n");
   }

   print_function_footer();
} # END create_rtl_view

#-------------------------------------------------------------------------------
#  Create the pincheck shell file and call it
#-------------------------------------------------------------------------------
sub run_pincheck_script($$$$$$$$$$$$$){
   print_function_header();
   prompt_before_continue( CRAZY );
   my $macro                 = shift;
   my $stack                 = shift;
   my $pincheckCmdSegment    = shift;
   my $relPathAbs            = shift;
   my $vmodule               = shift;
   my $projType              = shift;
   my $opt_dryrun            = shift;
   my $href_legalRelease     = shift;
   my %pincheckFiles         = %{+shift};
   my $href_pincheckLogFiles = shift;
   my $href_pincheckDirtys   = shift;
   my $href_pincheckWarnings = shift;
   my $aref_missingFiles     = shift;
   
   
   my ( $pincheckShellFile, $layersMacro, $supplyPinsMacro );
   my ( $pincheckCmd );
   
   if ($stack eq "0"){
      $pincheckShellFile               = "${relPathAbs}/${macro}/$href_legalRelease->{'rel'}".
                                       "/macro/alphaPinCheck.${macro}";
      $href_pincheckLogFiles->{$macro} = "${relPathAbs}/${macro}/$href_legalRelease->{'rel'}/".
                                       "macro/${macro}.pincheck";
   } else {
      $pincheckShellFile               = "${relPathAbs}/${macro}/$href_legalRelease->{'rel'}".
                                       "/macro/pincheck/$stack/alphaPinCheck.${macro}";
      $href_pincheckLogFiles->{$macro} = "${relPathAbs}/${macro}/$href_legalRelease->{'rel'}/".
                                       "macro/pincheck/$stack/${macro}.pincheck";
   }

   ## determine if macro has a layers override
   if( exists($href_legalRelease->{'layersOverrides'}->{$macro}) ){
      $layersMacro = $href_legalRelease->{'layersOverrides'}->{$macro};
   }else{
      $layersMacro = $href_legalRelease->{'layers'};
   }

   ## determine if macro has an override supply pin
   if( exists($href_legalRelease->{'supplyPinsOverrides'}->{$macro}) ){
      $supplyPinsMacro = $href_legalRelease->{'supplyPinsOverrides'}->{$macro};
   }else{
      $supplyPinsMacro = $href_legalRelease->{'supplyPins'};
   }

   ## set datestamp
   my $datePincheck = UnixDate($href_legalRelease->{'referenceDateTime'}, "%Y-%m-%d %H:%M:%S");
   
   ## seed pincheck run
   ## in TESTMODE mode the source file will have non-orientation specific RTL
   #my $tool = adjust_cmd_for_perl_coverage( "$RealBin/alphaPinCheck.pl" );
   my $tool = "$RealBin/alphaPinCheck.pl" ;
   $pincheckCmd = "\n$tool "
           ."  -tech  $href_legalRelease->{'process'} -since $datePincheck -dateRef CDATE -bracket square "
           ."  -lefObsLayers '$layersMacro' "
           ."  -lefPinLayers '$layersMacro' "
           ."  -PGlayers '$supplyPinsMacro' "
           ."  -macro $macro "
           ."  -log $href_pincheckLogFiles->{$macro} ";

   if( defined $opt_dryrun ){ 
      $pincheckCmd .= "\\\n  -nolog -vmodule $vmodule";
   }
   
   ## Appened the segment from the copy_files subroutine
   ## the segment contains behave type followed by the file name
   ## for macros not included in the shimMacros hash
   if(defined $pincheckCmdSegment){
      $pincheckCmd .= $pincheckCmdSegment;
   }

   #--------------------------------------------------------------
   # Verify that the pininfo files exist, else WARN user.
   #--------------------------------------------------------------
   # Make copy of the pincheckFiles hash, because
   #    check_exist_pininfo_files() modifies the hash.
   use Storable qw(dclone); 
   my $href_clone =  dclone(\%pincheckFiles);
   push(@$aref_missingFiles, check_exists_pininfo_files( $href_legalRelease, $macro, $href_clone )  );
   
   foreach my $file (keys %{$pincheckFiles{$macro}}){
        if( -e $file || $file =~ m/utility_(blocks|cells)/ ){
            $pincheckCmd .= "  -$pincheckFiles{$macro}->{$file} $file \\\n";
            viprint(MEDIUM,"\tFound $file $pincheckFiles{$macro}->{$file} file ".
                    "for pin check comparison\n");
        }
    }
   dprint_dumper(CRAZY, "", \%pincheckFiles );
   prompt_before_continue(CRAZY );
   ## write pincheck shell
   iprint( "\tWriting and executing $pincheckShellFile pin check shell script file...\n" );
   ##   check out pin check log if it exists
   if(-e $href_pincheckLogFiles->{$macro}){
      run_system_cmd( "p4 edit $pincheckShellFile $href_pincheckLogFiles->{$macro} |& ".
                      "cat >> $p4LogFile", $VERBOSITY );
      run_system_cmd( "p4 add $pincheckShellFile $href_pincheckLogFiles->{$macro} |& ".
                      "cat >> $p4LogFile", $VERBOSITY );
   ##    or add an empty file to seed depot
   }else{
      run_system_cmd( "touch $pincheckShellFile $href_pincheckLogFiles->{$macro}; ".
                      "p4 add $pincheckShellFile $href_pincheckLogFiles->{$macro} |& ".
                      "cat >> $p4LogFile", $VERBOSITY );
   }
   my @lines;
   ## remove pincheck log file, so we can append it, for repeater & utility macro cells
   push(@lines, "rm $href_pincheckLogFiles->{$macro}\n" );
   ## Need to check submacros for utility macros for all families, repeater macros if they have submacros 
   if( grep{/$macro/} @{$href_legalRelease->{'utilityMacro'}} ){
      ## we need to check each level 1 cell, instead of level 0 (top level)
      foreach my $cell ( @{$href_legalRelease->{'phyvMacros'}->{$macro}} ){
         ## so swap cell for macro
         my $cmd = $pincheckCmd;
         ## changes pin check macro name
         $cmd =~ s/\-macro $macro\b/\-macro $cell/;
         ## changes pin check vmodule name for TESTMODE
         $cmd =~ s/\-vmodule $macro\b/\-vmodule $cell/;
         ## changes pin info CSV file to be used to cell version
         dprint(CRAZY, "converting pininfo file from => to:\n\t $macro.csv => $cell.csv\n" );
         $cmd =~ s/$macro\.csv\b/$cell.csv/;
         $cmd =~ s/\s*\/\s*$//;
         $cmd =~ s|(\S)\s\\$|$1|;
         #dprint(NONE, "MCMD=$cmd\n" );
         #prompt_before_continue(NONE );
         push(@lines, $cmd );
      }
    }
    elsif( (grep{/$macro/} @{$href_legalRelease->{'repeaterMacro'}}) && (defined $href_legalRelease->{'repeaterSubMacros'}->{$macro})){
        foreach my $cell ( @{$href_legalRelease->{'repeaterSubMacros'}->{$macro}} ){
            ## so swap cell for macro
            my $cmd = $pincheckCmd;
            ## changes pin check macro name
            $cmd =~ s/\-macro $macro\b/\-macro $cell/;
            ## changes pin check vmodule name for TESTMODE
            $cmd =~ s/\-vmodule $macro\b/\-vmodule $cell/;
            ## changes pin check CSV file to be used to cell version
            $cmd =~ s/$macro\.csv\b/$cell.csv/;
            $cmd =~ s|(\S)\s\\$|$1|;
            push(@lines, $cmd );
        }
    }
   ## for all other macros, just dump the pin check command
   else{
      $pincheckCmd =~ s|(\S)\s\\$|$1|;
      push(@lines, $pincheckCmd );
   }
   write_file( \@lines, $pincheckShellFile );
   chmod 0775, $pincheckShellFile;
   ## run pincheck script
   my $cmd = "$pincheckShellFile";
   viprint(LOW, "\t\$ $cmd\n");
   if( defined $opt_dryrun ){
      iprint("In DEBUG mode, pincheck compares source files, not released files\n");
   }
   
   ##   call the shell file
   run_system_cmd( $cmd, $VERBOSITY );
   
   my ( $pincheckDirtysCount, $pincheckWarningsCount ); 
   ## interrogate pincheck file for DIRTY checks
   unless( -e $href_pincheckLogFiles->{$macro} ){
      wprint("pincheck log file '$href_pincheckLogFiles->{$macro}' does not exist!\n");
      push(@$aref_missingFiles, $href_pincheckLogFiles->{$macro});
   }else{
      iprint("\tChecking '$href_pincheckLogFiles->{$macro}' pin check log file...\n");
      ( $pincheckDirtysCount, $pincheckWarningsCount ) 
                        = countDirtysAndWarnings($href_pincheckLogFiles->{$macro});
      if( $pincheckDirtysCount > 0 ){
         $href_pincheckDirtys->{$macro} = $pincheckDirtysCount;
      }
      if( $pincheckWarningsCount > 0 ){
         $href_pincheckWarnings->{$macro} = $pincheckWarningsCount;
      }
   }
   
   ## p4 opened file
   viprint(LOW, "\tList opened P4 files\n");
   $cmd = "p4 opened ${relPathAbs}/${macro}/$href_legalRelease->{'rel'}/macro/... |& cat >> $p4LogFile";
   run_system_cmd( $cmd, $VERBOSITY );
   
   print_function_footer();
   # End of run_pincheck_script
}

#--------------------------------------------------------------
# SPECIAL CASE: Utility blocks/cells
#--------------------------------------------------------------
sub check_exists_pininfo_files($$$) {
   print_function_header();
   my $href_legalRelease = shift;
   my $macro = shift;
   my $href  = shift;

   my %pincheckFiles = %$href;

   #--------------------------------------------------------------
   # SPECIAL CASE: Utility blocks/cells
   #--------------------------------------------------------------
   # if utility, we need to check that the pininfo CSV file exists
   #     for each sub-macro, rather than the top-level macro
   #     named 'dwc_*_utility_blocks' or 'dwc_*_utility_cells'
   #
   #     So, replace single macro's pininfo file with one for
   #     each sub-macro in the hash.
   #
   #     $RelPath =  '/remote/cad-rep/projects/lpddr5x/d931-lpddr5x-tsmc3eff-12/rel1.00_cktpcs/'
   #---------
   #     START with ...
   #---------
   #  %pincheckFiles = ( 
   #      'dwc_lpddr5xphy_utility_blocks' => {
   #         "$RelPath/design/pininfo/1.00a_pre3/dwc_lpddr5xphy_utility_blocks.csv" => 'pinCSV'
   #      }
   #  );
   #---------
   #  TRANSFORM into ...
   #---------
   #  %pincheckFiles = ( 
   #     'dwc_lpddr5xphy_utility_blocks' => {
   #         "$RelPath/design/pininfo/1.00a_pre3/dwc_lpddr5xphy_vdd2hclamp_x6_ew.csv" => 'pinCSV',
   #         "$RelPath/design/pininfo/1.00a_pre3/dwc_lpddr5xphy_vdd2hclamp_ew.csv"    => 'pinCSV',
   #         "$RelPath/design/pininfo/1.00a_pre3/dwc_lpddr5xphy_decapvddq_x3_ew.csv"  => 'pinCSV',
   #         ...
   #      }
   #  );
   #--------------------------------------------------------------
   if( $macro =~ m/_utility_blocks/ ){
      my $href =  $pincheckFiles{$macro};
      foreach my $file ( keys %$href ){
          delete $href->{$file};
          if( $file =~ m/.*_utility_blocks.csv/ ){
            if( grep{/$macro/} @{$href_legalRelease->{'utilityMacro'}} ){
                foreach my $cell ( @{$href_legalRelease->{'phyvMacros'}->{$macro}} ){
                    my $tmp = $file;
                    $tmp =~ s|/dwc_.*utility_blocks.csv$|/$cell.csv|;
                    $href->{$tmp} = 'pinCSV';
                }
             }
          }
       }
   }
   #--------------------------------------------------------------
   ## Check to verify that the pininfo file exists for each macro
   ##    for utility_blocks/utility_cells, check each and every
   ##    sub-macro's pininfo exists ($macro.csv).
   my( @missing_files);
   foreach my $file (keys %{$pincheckFiles{$macro}}){
      if( !-e $file ){
         wprint( "\tCound not find $file $pincheckFiles{$macro}->{$file} file, ".
                 "so skipping for pin check comparison...\n" );
         push(@missing_files, $file );
      }elsif( -z $file ){
         wprint( "\tZero size for $file $pincheckFiles{$macro}->{$file} file, ".
                 "so skipping for pin check comparison...\n" );
         push(@missing_files, $file );
      }
   }

   print_function_footer();
   return( @missing_files);
}

#-----------------------------------------------------------------------------
#   The disk path provided for where the p4 //depot data was sycn'd must exist. 
#       If the path doesn't exist, then FATAL, otherwise check the ckt data exists.
#       Ckt data is found under the area: //depot/.../ckt/rel  
#       Make sure the data is sync'd to the disk path provided.
#-----------------------------------------------------------------------------
sub set_release_path($$$$){
   print_function_header();
   my $relPathBase       = shift;
   my $p4client          = shift;
   my $proj              = shift;
   my $projType          = shift;
   my $p4ReleaseRoot     = shift;
   
   ## verify existence of release path
   unless( -e $relPathBase ){
      fatal_error( "P4 path $relPathBase does not exist.\n".
              "Please ensure that a sym-link to the P4 workspace exists (e.g. ~/p4_ws).\n" );
   }
   # verify existence of disk area where they sync'd the depot from
   #      Perforce (release area : //depot/products/$product/.../project/$project/ckt/rel/$rel/... )
   #      User     (release area : $HOME/$opt_p4ws/products/$product/... )
   #      If doesn't exist, provide line need to add to the p4 client.
   #      From legalRelease.txt ... example of p4ReeleaseRoot
   #              set p4_release_root "products/lpddr5x_ddr5_phy/lp5x/project/d930-lpddr5x-tsmc5ff12"
   my $relPath = "$relPathBase/$p4ReleaseRoot/ckt/rel";
   unless( -e $relPath ){
      fatal_error( "Release path $relPath does not exist.\n".
              "Please check that this work space 'p4 client' contains \n".
              "\t//depot/$p4ReleaseRoot/... \n".
              "\t//$p4client/$p4ReleaseRoot/...\n" );
   }
   
   print_function_footer();
   return( abs_path($relPath) );
   # End of set_release_path
}

#-----------------------------------------------------------------------------
sub print_p4_submit_command($$$$){
   print_function_header();
   my $rel        = shift;
   my $relPathAbs = shift;
   my $debug      = shift;
   my @macros     = @{+shift};
   
   ## p4 submit command
   if( defined $debug ){
      iprint("DEBUG: No p4 files to submit\n");
   }else{
       p4print( "To complete release deliverables submission to the depot:\n" );
       foreach my $macro (@macros){
          p4print( "p4 submit -d 'Release $rel of macro $macro behavioral views' ".
                   "${relPathAbs}/${macro}/$rel/...\n" );
       }
       p4print( "or\n" );
       foreach my $macro (@macros){
          p4print( "p4 submit -d 'Release $rel of macro $macro behavioral views, ".
                   "updated to fix XYZ' ${relPathAbs}/${macro}/$rel/...\n" );
       }
   }
   
   print_function_footer();
}

#-----------------------------------------------------------------------------
#  Inform user of pincheck warnings & errors, and warn about
#     any missing files.
#-----------------------------------------------------------------------------
sub print_warnings($$$$$$){
   print_function_header();
   my $debug            = shift;
   my %pincheckWarnings = %{+shift};
   my %pincheckDirtys   = %{+shift};
   my %pincheckLogFiles = %{+shift};
   my @macros           = @{+shift};
   my @missingFiles     = @{+shift};
   
   ## warn about any pincheck warning
   foreach my $macro (@macros){
       ## warn about any pincheck warning
      if( exists $pincheckWarnings{$macro} ){

         nprint "\n";
         wprint("There were '$pincheckWarnings{$macro}' checks that were 'Warning' in the ".
               "'$macro' macro pincheck run.\n".
               "\tThe warnings are listed in the pin check log file:\n".
               "\t\t'$pincheckLogFiles{$macro}'\n".
               "\tThese items may be acceptable, but please review them.\n");
      }    
   }

   ## warn about any pincheck dirty/error
   foreach my $macro (@macros){
       if( exists $pincheckDirtys{$macro} ){

         nprint "\n";
         eprint("There were '$pincheckDirtys{$macro}' checks that were 'DIRTY/Error' in the ".
               "'$macro' macro pincheck run.".
               "\tThe failed checks are listed in the pin check log file:\n".
               "\t\t'$pincheckLogFiles{$macro}'\n".
               "\tPlease fix all DIRTY checks, or get waivers from the CKT lead.\n");
      }     
   }

   ## warn about any missing files
   ##    It is a WARNING (not an ERROR) if the /.../pininfo/.../*.csv file is mising
   ##    for the macros -> repeater_blocks, repeater_cells, utility_blocks, utility_cells,
   if( $#missingFiles >= 0 ){
        nprint "\n";
        eprint( "There were missing source behavioral files:\n\n".
                join("\n\t\t",@missingFiles).
                "\n\tPlease create the missing source files, or get waivers from the CKT lead.\n" );
   }

   print_function_footer();
}

#----------------------------------------------------------
sub process_cmd_line_args(){      
   my ( $opt_projSPEC, $opt_macros, $opt_dryrun, $opt_verbosity, $opt_debug, $opt_help,
        $opt_nousage, $opt_cosimUniq, $opt_p4ws);
   
   my $success = GetOptions(
      "p=s"          => \$opt_projSPEC,
      "macros=s"     => \$opt_macros,
      "p4ws=s"       => \$opt_p4ws,
      "dryrun!"      => \$opt_dryrun,
      "verbosity=i"  => \$opt_verbosity,
      "debug=i"      => \$opt_debug,
      "help"         => \$opt_help, 
      "nousage"      => \$opt_nousage,
      "cosimUniq:s"  => \$opt_cosimUniq,
   );

    $main::VERBOSITY = $opt_verbosity if( defined $opt_verbosity );
    $main::DEBUG     = $opt_debug     if( defined $opt_debug     );
		$main::TESTMODE  = 1              if( defined $opt_dryrun  && $opt_dryrun == 1 );

    ## quit with usage message, if usage not satisfied
    &usage(0) if $opt_help;
    &usage(1) unless( $success );
    &usage(1) unless( defined $opt_projSPEC );

    $opt_cosimUniq = 1 unless( defined $opt_cosimUniq ); # ON by default
   
    return( $opt_projSPEC, $opt_macros,    $opt_dryrun,
            $opt_nousage,  $opt_cosimUniq, $opt_p4ws );
} # End of process_cmd_line_args

#-----------------------------------------------------------------------------
sub usage($) {
    my $exit_status = shift;

    print << "EOP" ;
Description
  A script to copy behavioral views from the project design directory structure
    /remote/cad-rep/projects/<projSPEC>/design[_unrestricted]/
  To the depot release path, defined from variables in the project release file:
    /remote/cad-rep/projects/<projSPEC>/design[_unrestricted]/legalRelease.txt
  for the macros in the project macro file:
    /remote/cad-rep/projects/<projSPEC>/design[_unrestricted]/topcells.txt
  These files include:
  - RTL view - copied and abstracted to just the <macro>_interface.v shell Verilog:
      .../design/rtl/<rel>/<macro>.v
  - COSIM views - copied:
      .../design/cosim/<rel>/<macro>_<process>.sp  and  .../design/cosim/<rel>/corners.inc


USAGE : $PROGRAM_NAME [options] -p <projSPEC>

------------------------------------
Required Args:
------------------------------------
-p       <projSPEC>   <project_type>/<project>/<CD_rel>


------------------------------------
Optional Args:
------------------------------------
-help              print this screen
-macros     <arg>  macros to release, space or comma-separated 
-cosimUniq         uniquifying COSIM views (if conflicts between macros); 
                         ON by default;   use -cosimUniq 0 to disable
-p4ws       <arg>  Overrides path to your personal Perforce work area (default: \$HOME/p4_ws)
-dryrun            do not execute p4 commands (other than status/opened)
-nousage           do not report the usage of this script
-verbosity  <#>    print additional messages ... includes details of system calls etc. 
                   Must provide integer argument -> higher values increases verbosity.
-debug      <#>    print additional diagnostic messagess to debug script
                   Must provide integer argument -> higher values increases messages.

Assumptions:
- Requires that the depot has been seeded (with blank or old files), so that all files exist

EOP
    exit($exit_status);
}

1;  # Required for unit testing

# Copyright (c) 2004-2015 Synopsys, Inc. This Galaxy Custom Designer software# and the associated documentation are confidential and proprietary to# Synopsys, Inc. Your use or disclosure of this Galaxy Custom Designer software# is subject to the terms and conditions of a written license agreement between# you, or your company, and Synopsys, Inc.namespace eval ::amd::editPDKLePwrGrid {variable updateFlag trueproc init {self context {args ""}} {    variable updateFlag       if {"maskLayout" != [db::getAttr context.editDesign.viewType]} {       error "Can only drawing power grid in a layout view"       }    db::setAttr self.canBeKilled -value false       set updateFlag true            array set PdkEnv $::amd::PdkEnv     if [info exists  amd::AMDPDKgvarLibList] {        array set  AMDPDKgvarLibArray  $amd::AMDPDKgvarLibList ;    } else {        array set  AMDPDKgvarLibArray [list];    }    if [info exists AMDPDKgvarLibArray(defGridSpec)] {        set defGridSpecList $AMDPDKgvarLibArray(defGridSpec);    } else {        set defGridSpecList [list]    }    if ![info exists AMDPDKgvarLibArray(defGridOpts)] {        set AMDPDKgvarLibArray(defGridOpts) nil    }#    if [info exists AMDPDKgvarLibArray(amdPwrGridVias)] {        set AMDPDKgvarLibArray(amdPwrGridVias)  $PdkEnv(pwrgridVias)#    }             set AMDPDKgvarLibArray(metals) $PdkEnv(pwrgridMetals);    if [info exists AMDPDKgvarLibArray(defGridDirs)] {        array set defGridDirsArray $AMDPDKgvarLibArray(defGridDirs);    } else {        array set defGridDirsArray $PdkEnv(metalRoutingDirections);        set AMDPDKgvarLibArray(defGridDirs) $PdkEnv(metalRoutingDirections)    }    foreach metal $AMDPDKgvarLibArray(metals) {        if [info exists defGridDirsArray($metal)] {           set AMDPDKgvarLibArray([join [list PG $metal _dir] ""]) $defGridDirsArray($metal);        } else {           set AMDPDKgvarLibArray([join [list PG $metal _dir] ""]) horizontal        }        set AMDPDKgvarLibArray([join [list PG $metal _viastyle] ""]) 2x2    }        set gridSpecList [list] ; #initial value    set instName ""                                 ; #initial value     db::setAttr self.engine -value \        [de::createSelectionEngine -filterProc [namespace current]::filterSelected ]    set AMDPDKgvarLibArray(defGridSpec) $defGridSpecList    set design [db::getAttr context.editDesign]        array set argArray $args;    if {[info exists argArray(-instName)] && [info exists argArray(-gridSpec)]} {        set AMDPDKgvarLibArray(instName) $argArray(-instName);        set AMDPDKgvarLibArray(gridSpec) $argArray(-gridSpec);    }    db::setAttr self.clientData -value [array get AMDPDKgvarLibArray]    }proc toolbarCreated {self toolBar} {    set context [db::getNext [db::getAttr self.contexts]]     catch {gi::pressButton {eject} -in [gi::getToolbars {deCommandOptions} -from [db::getAttr context.window]]}    de::sendMessage "Dialog for this command cannot be hidden" -severity warning}    proc buildMspecList {mspecs} {    set retlist [list]    foreach item [lindex $mspecs 0] {        set metal [lindex $item 0]        set pitch [lindex $item 1]         set wires [lindex $item 2]        set mwires [list]        foreach wire $wires {            set stub [list]            set name [list]                foreach item [lrange $wire 3 end] {                switch [lindex $item 0] {                    pullBL    { set pullBL [list pullBL [lindex $item 1]]}                    pullTR    { set pullTR [list pullTR [lindex $item 1]]}                    name    { set name [list name [lindex $item 1]]}                        stub    { set stub [list stub [lindex $item 1]]}                }            }            set mwire [list [lindex $wire 0] [lindex $wire 1] [lindex $wire 2] $pullBL $pullTR];            if [llength $name] {                lappend mwire $name                }            if [llength $stub] {                lappend mwire $stub            }            lappend mwires $mwire        }        lappend retlist $metal         lappend retlist [list $pitch $mwires];    }    return $retlist}proc flatList {lst} {    set retlist [list];    foreach item [lindex $lst 0] {        lappend retlist [lindex $item 0];        lappend retlist [lindex $item 1];    }    return $retlist}        proc selectionChanged {self design} {    array set AMDPDKgvarLibArray [db::getAttr self.clientData];    set selected [de::getSelected -design $design]    set dialog [db::getAttr self.dialog];    if [catch {set defsFld [gi::findChild defsFld -in $dialog]}] {        return     }    if {1 != [db::getCount $selected]} {        db::setAttr defsFld.items -value [list]         return        }    if {"ScalarInst" != [db::getAttr selected.object.type]} {        de::sendMessage "Wrong object is selected [db::getAttr selected.object.type]" -severity warning;        db::setAttr defsFld.items -value [list]         return    }    set iLibName [db::getAttr selected.object.libName ];    set iCellName [db::getAttr selected.object.cellName ];    set iViewName [db::getAttr selected.object.viewName];    set iName [db::getAttr selected.object.name]    if {[db::getPrefValue amdPwrGrdCellView] != [join [list $iLibName $iCellName $iViewName] /]} {        de::sendMessage "Wrong inst object is selected [join [list $iLibName $iCellName $iViewName]]" -severity warning;        db::setAttr defsFld.items -value [list]         return    }    set mspecsParam [string map {"(" "{" ")" "}" "nil" "{}" "\"" ""} [db::getAttr selected.object.mspecs]];    set mdirectionsParam [string map {"(" "{" ")" "}" "nil" "{}" "\"" ""} [db::getAttr selected.object.mdirections]]    set stdViaListParam [string map {"(" "{" ")" "}" "nil" "{}" "\"" ""} [db::getAttr selected.object.stdViaList]]    set metallistParam [string map {"(" "{" ")" "}" "nil" "{}" "\"" ""} [db::getAttr selected.object.metallist]]    set optsParam     [string map {"(" "{" ")" "}" "nil" "{}" "\"" ""} [db::getAttr selected.object.opts]];    set gridSpec [[namespace current]::buildMspecList $mspecsParam]        set stdViaList [lindex $stdViaListParam 0];    set metals [lindex $metallistParam 0];    set opts [lindex $optsParam 0];    set mdirs [list]    foreach item  [lindex $mdirectionsParam 0] {        set metal [lindex $item 0];        set dir [lindex $item 1]        set AMDPDKgvarLibArray([join [list PG $metal _dir] ""]) $dir;    }    set AMDPDKgvarLibArray(instName) $iName    set AMDPDKgvarLibArray(mdPwrGridVias) $stdViaList;        set AMDPDKgvarLibArray(gridSpec) $gridSpec;    set AMDPDKgvarLibArray(metals) $metals;    db::setAttr self.clientData -value [array get AMDPDKgvarLibArray]    set dialog [db::getAttr self.dialog];    set metalFld [gi::findChild metalFld -in $dialog];    set enum [db::getAttr metalFld.enum]    if [llength $gridSpec] {        set m1 [lindex $gridSpec 0]    } else {        set m1 [lindex $enum 1]    }        set ind1 [lsearch $enum $m1];    set length [llength $enum];    set nind [expr int(fmod(($ind1 + 1), ($length - 1)))];    db::setAttr metalFld.value -value [lindex $enum $nind];    db::setAttr metalFld.value -value $m1;    }        proc filterSelected {self selected} {    set lcv [db::getPrefValue amdPwrGrdCellView];       set grdCellLibName [lindex [split $lcv /] 0];       set grdCellName [lindex [split $lcv /] 1];       set grdCellViewName [lindex [split $lcv /] 2];    if {"Inst" == [db::getAttr selected.objType] && [db::getAttr selected.object.master.libName] == $grdCellLibName && [db::getAttr selected.object.master.cellName] == $grdCellName && [db::getAttr selected.object.master.viewName] == $grdCellViewName} {        return true    } else {        return false    }}    proc amdGetPathWidth {cmd dialog engine} {    db::setAttr cmd.prompt -value "";    set context [db::getNext [db::getAttr cmd.contexts]];    set points [db::getAttr points -of [db::getAttr engine -of $cmd]];    if [[namespace current]::amdPDKPwrGridIsLayVert $cmd [gi::findChild metalFld.value -in $dialog]] {             set val [expr abs([lindex $points 0 0] - [lindex $points 1 0])];    } else {        set val [expr abs([lindex $points 0 1] - [lindex $points 1 1])];    }    set widthFld [gi::findChild widthFld -in $dialog];    db::setAttr widthFld.value -value $val;    db::setAttr cmd.engine -value \        [de::createSelectionEngine -filterProc [namespace current]::filterSelected ]}proc amdPDKLePwrGridGetWidth {cmd widget} {    set prompt "Draw segment describing wire width";    db::setAttr cmd.prompt -value $prompt;    set dialog [db::getAttr widget.parent ]    db::setAttr cmd.engine -value \        [de::createShapeEngine -angleMode diagonal \        -shapeType line -numPoints 2\        -completeProc [list [namespace current]::amdGetPathWidth $cmd $dialog]];        }proc amdPDKMod {a b} {    if $b {        return [expr $a - floor($a/$b) * $b]    } else {        return $a    }}proc amdGetPathPos {cmd dialog engine} {    set metal [gi::findChild metalFld.value -in $dialog]     db::setAttr cmd.prompt -value "";    set context [db::getNext [db::getAttr cmd.contexts]];    set clientData [db::getAttr cmd.clientData];    array set clientDataArray $clientData;    set instName $clientDataArray(instName)    set inst [db::getNext [db::getInsts $instName -of [db::getAttr context.editDesign]]];    set itransform [oa::invert [db::getAttr inst.transform]];    set points [db::getAttr points -of [db::getAttr engine -of $cmd]];    set ipoints [oa::transform [oa::Point [lindex $points 0 0] [lindex $points 0 1]] $itransform];    set direction horizontal ;     if [[namespace current]::amdPDKPwrGridIsLayVert $cmd $metal] {        set val [lindex $ipoints 0];    } else {        set val [lindex $ipoints 1];    }    set pitchFldValue [gi::findChild pitchFld.value -in $dialog]    set val [[namespace current]::amdPDKMod $val $pitchFldValue]    set posFld [gi::findChild posFld -in $dialog];    db::setAttr posFld.value -value $val;    db::setAttr cmd.engine -value \        [de::createSelectionEngine -filterProc [namespace current]::filterSelected ];}proc amdPDKLePwrGridGetPos {cmd widget} {    set prompt "Click on center position of wire";    db::setAttr cmd.prompt -value $prompt;    set dialog [db::getAttr widget.parent ]    db::setAttr cmd.engine -value \        [de::createShapeEngine \        -shapeType  point \        -completeProc [list [namespace current]::amdGetPathPos $cmd $dialog]];        }proc amdPDKListLookup {lst key {def ""}} {    set myLst [list]    foreach item $lst {        lappend myLst [lindex $item 0];        lappend myLst [lindex $item 1];    }    array set myArray $myLst;    if [info exists myArray($key)] {        return $myArray($key)    }    return $def}           proc amdPDKLePwrGridTxt {items} {    set retList [list];    foreach item $items {        set str [format "%-7s Wid=%5.3f Pos=%5.3f" [lindex $item 0 ] [lindex $item 1 ] [lindex $item 2 ] ];         set ext [[namespace current]::amdPDKListLookup [lrange $item 3 end] name];         if {"" != $ext} { set str [format "%s Net=%s" $str $ext] }         set ext [[namespace current]::amdPDKListLookup [lrange $item 3 end] split];         if {"" != $ext} { set str [format "%s Split=%s" $str $ext] }         set ext [[namespace current]::amdPDKListLookup [lrange $item 3 end] pullBL];         if {"" != $ext} { set str [format "%s pullBL=%1.3f" $str $ext] }        set ext [[namespace current]::amdPDKListLookup [lrange $item 3 end] pullTR];         if {"" != $ext} { set str [format "%s pullTR=%1.3f" $str $ext] }             set ext [[namespace current]::amdPDKListLookup [lrange $item 3 end] stub];             if {"" != $ext} { set str [format "%s Stub=%1.3f %1.3f %1.3f %1.3f" $str [lindex $ext 0] [lindex $ext 1] [lindex $ext 2] [lindex $ext 3]] }            lappend retList $str    }    return $retList}     proc resetGridModify {} {    variable updateFlag    set updateFlag true    }              proc amdPDKLePwrGridRefreshList {cmd widget} {    variable updateFlag    array set AMDPDKgvarLibArray [db::getAttr cmd.clientData];    set     updateFlag false    after idle [namespace current]::resetGridModify         set dialog [db::getAttr widget.parent];    set purpFld [gi::findChild purpFld -in $dialog];    db::setAttr purpFld.value -value track    set defsFld [gi::findChild defsFld -in $dialog];    set pitchFld [gi::findChild pitchFld -in $dialog];    set mdir [gi::findChild mdirFld -in $dialog]     set metal [db::getAttr widget.value];    set items [list]    set pitch 0.0    if [info exists AMDPDKgvarLibArray(gridSpec)] {        array set gridSpecArray $AMDPDKgvarLibArray(gridSpec)        if [info exists gridSpecArray($metal)] {            db::setAttr pitchFld.value -value [lindex $gridSpecArray($metal) 0];            set items [[namespace current]::amdPDKLePwrGridTxt [lindex     $gridSpecArray($metal) 1]];            db::setAttr defsFld.items -value $items;            db::setAttr mdir.value \                -value $AMDPDKgvarLibArray([join [list PG $metal _dir] ""]);            set pitch [lindex $gridSpecArray($metal) 0];            }        }     db::setAttr pitchFld.value -value $pitch;    db::setAttr defsFld.items -value $items    [namespace current]::amdPDKLePwrGridUpdLbls $cmd $metal $dialog;}proc amdPDKPwrGridIsLayVert {cmd layerName} {    array set AMDPDKgvarLibArray [db::getAttr cmd.clientData ];    return [expr {$AMDPDKgvarLibArray([join [list PG $layerName _dir] ""]) == "vertical"}]}proc amdPDKLePwrGridUpdLbls {cmd metal dialog} {    set pulBLFld [gi::findChild pulBLFld -in $dialog];    set pulTRFld [gi::findChild pulTRFld -in $dialog];    set spullBLBut [gi::findChild spullBLBut -in $dialog];    set spullTRBut [gi::findChild spullTRBut -in $dialog];    if [[namespace current]::amdPDKPwrGridIsLayVert $cmd $metal] {        db::setAttr pulBLFld.label  -value "Bot pullback";        db::setAttr pulTRFld.label  -value "Top pullback";        db::setAttr spullBLBut.label -value "Bot pullback";        db::setAttr spullTRBut.label -value "Top pullback";    } else {        db::setAttr pulBLFld.label  -value "Left pullback";        db::setAttr pulTRFld.label  -value "Right pullback";        db::setAttr spullBLBut.label -value "Left pullback";        db::setAttr spullTRBut.label -value "Right pullback";    }}proc amdPDKLePwrGridSelectCB {cmd widget} {   set dialog [db::getAttr widget.parent];   set widthFld [gi::findChild widthFld -in $dialog];   set posFld [gi::findChild posFld -in $dialog];   set nameFld [gi::findChild nameFld -in $dialog];   set pulBLFld [gi::findChild pulBLFld -in $dialog];   set pulTRFld [gi::findChild pulTRFld -in $dialog];   set purpFld [gi::findChild purpFld -in $dialog];   set selList [db::getAttr widget.value];   set stubFld [gi::findChild stubFld -in $dialog]   db::setAttr purpFld.value -value [lindex $selList 0 0];   set selected [join $selList];                 if [regexp {Wid=([0-9.]+)} $selected a width] {       db::setAttr widthFld.value -value $width   } else {       db::setAttr widthFld.value -value 0.0   }   if [regexp {Pos=([-0-9.]+)} $selected a pos] {       db::setAttr posFld.value -value $pos   } else {       db::setAttr posFld.value -value 0.0   }   if [regexp {Net=([a-zA-Z_0-9]+)} $selected a net] {       db::setAttr nameFld.value -value $net;   } else {       db::setAttr nameFld.value -value ""   }      if [regexp {pullBL=([-0-9.]+)} $selected a bl] {       db::setAttr pulBLFld.value -value $bl   } else {       db::setAttr pulBLFld.value -value 0.0   }   if [regexp {pullTR=([-0-9.]+)} $selected a tr] {       db::setAttr pulTRFld.value -value $tr   } else {       db::setAttr pulTRFld.value -value 0.0   }   if [regexp {Stub=(.+)} $selected a stub] {       db::setAttr stubFld.value -value $stub   } else {       db::setAttr stubFld.value -value ""   }       }       proc amdPDKLePwrGridPurpChange {widget} {  set dialog [db::getAttr widget.parent];  set value [db::getAttr widget.value];  set nameFld [gi::findChild nameFld -in $dialog];  switch $value {      vss {db::setAttr nameFld.value -value VSS}      vdd {db::setAttr nameFld.value -value VDD}      default {db::setAttr nameFld.value -value ""}  }}proc amdPDKLePwrGridUpd {cmd} {    set design [db::getAttr editDesign -of [db::getNext [db::getAttr cmd.contexts]]];    array set AMDPDKgvarLibArray [db::getAttr cmd.clientData];    set inst [db::getNext [db::getInsts $AMDPDKgvarLibArray(instName) -of $design]];    set maxx [db::getAttr inst.maxx];    set maxy [db::getAttr inst.maxy];    set minx [db::getAttr inst.minx];    set miny [db::getAttr inst.miny];    set gspec $AMDPDKgvarLibArray(gridSpec);    set gopts  $AMDPDKgvarLibArray(defGridOpts);    set metals $AMDPDKgvarLibArray(metals);    set mdirs "";    foreach metal  $metals {        lappend mdirs $metal;        lappend mdirs $AMDPDKgvarLibArray([join [list PG $metal _dir] ""]);    }    set mspecs         [amd::_formatMspec $gspec];    set mdirections [amd::formatMap $mdirs ];    set stdViaList     [amd::_formatLst $AMDPDKgvarLibArray(amdPwrGridVias)];    set opts         [amd::formatMap $gopts];    set metallist     [amd::_formatLst $metals]        set trans [de::startTransaction "Modify Power Grid" -design $design];     set app [oa::ParamArray];    db::setParamValue enable -type string -value  nil -of $inst    amd::_setAppValue app mspecs $mspecs    amd::_setAppValue app mdirections $mdirections    amd::_setAppValue app stdViaList $stdViaList     amd::_setAppValue app metallist $metallist    amd::_setAppValue app opts $opts                  oa::setParams $inst $app;    db::setParamValue minx -type float -value $minx  -of $inst    db::setParamValue miny -type float -value $miny  -of $inst    db::setParamValue maxx -type float -value $maxx  -of $inst    db::setParamValue maxy -type float -value $maxy  -of $inst    db::setParamValue enable -type string -value  toolPlaced -of $inst    de::endTransaction $trans}               proc amdPDKLePwrGridModCB {cmd widget} {    set dialog [db::getAttr widget.parent];    set defsFld [gi::findChild defsFld -in $dialog];    set def [lindex [db::getAttr defsFld.value] 0];    set items [db::getAttr defsFld.items]    if {"" == $def} {        de::sendMessage "Can't modify since nothing is selected" -severity warning        return    }    set width [expr double([gi::findChild widthFld.value -in $dialog])];    if {0 == $width} {        de::sendMessage "Width cannot be zero" -severity error;        return    }    set pos [expr double([gi::findChild posFld.value -in $dialog])]    set name [gi::findChild nameFld.value -in $dialog];    set bl [expr double([gi::findChild pulBLFld.value -in $dialog])];    set tr [expr double([gi::findChild pulTRFld.value -in $dialog])];    set purp [gi::findChild purpFld.value -in $dialog];    set metal [gi::findChild metalFld.value -in $dialog];    set stubVal [list];    foreach s [gi::findChild stubFld.value -in $dialog] {        lappend stubVal [expr double($s)]    }                array set clientData [db::getAttr cmd.clientData];    array set gridSpec $clientData(gridSpec);    set old_purp [lindex $def 0]     set old_wid [expr double([lindex [split [lindex $def 1] =] 1])]    set old_pos    [expr double([lindex [split [lindex $def 2] =] 1])]    set i 3;    set old_name [list]    if {"Net" == [lindex [split [lindex $def 3] =] 0]} {        set old_name [list name [lindex [split [lindex $def $i] =] 1]];        incr i    }    set old_pullBL_val [expr double([lindex [split [lindex $def $i] =] 1])];    incr i    set old_pullTR_val [expr double([lindex [split [lindex $def $i] =] 1])];    incr i    set oldwspec [list $old_purp $old_wid $old_pos [list pullBL $old_pullBL_val] [list pullTR $old_pullTR_val]]     if [llength $old_name] {        lappend oldwspec $old_name    }    if [regexp {Stub=(.+)} $def a stub] {      set off [expr double([lindex $stub 0])];      set len [expr double([lindex $stub 1])];        set spitch [expr double([lindex $stub 2])]      set minl [expr double([lindex $stub 3])]                    lappend oldwspec [list stub [list $off $len $spitch $minl]]    }    set ind [lsearch -glob  [lindex $gridSpec($metal)  1]  $oldwspec];    set newwspec [list $purp $width $pos [list pullBL $bl] [list pullTR $tr]];            set str [format "%-7s Wid=%5.3f Pos=%5.3f" $purp $width $pos];        if {"" != $name} {        set str [format "%s Net=%s pullBL=%1.3f pullTR=%1.3f" $str $name $bl $tr]        lappend newwspec [list name $name]        } else {        set str [format "%s pullBL=%1.3f pullTR=%1.3f" $str $bl $tr]    }    if {"" != $stubVal} {        set str [format "%s %1.3f %1.3f %1.3f %1.3f" $str [lindex $stubVal 0] [lindex $stubVal 1] [lindex $stubVal 2] [lindex $stubVal 3]];        lappend newwspec [list stub $stubVal];                }    set i [lsearch $items $def ]    set items [lreplace $items $i $i $str];    db::setAttr defsFld.items -value $items;    db::setAttr  defsFld.value -value [list $str]    set updatedspec [lreplace [lindex $gridSpec($metal) 1] $ind $ind $newwspec];    set gridSpec($metal) [lreplace $gridSpec($metal) 1 1 $updatedspec]    set clientData(gridSpec) [array get gridSpec];    db::setAttr cmd.clientData -value [array get clientData];    [namespace current]::amdPDKLePwrGridUpd $cmd }proc amdPDKLePwrGridAddCB {cmd widget} {    set dialog [db::getAttr widget.parent];    set defsFld [gi::findChild defsFld -in $dialog];    set items [db::getAttr defsFld.items];    set width [expr double([gi::findChild widthFld.value -in $dialog])];    set stub  [gi::findChild stubFld.value -in $dialog];         if {0 == $width} {        de::sendMessage "Width cannot be zero" -severity error;        return    }    set pos [expr double([gi::findChild posFld.value -in $dialog])];    set name [gi::findChild nameFld.value -in $dialog];    if {"" == $name} { set name e1 }    set bl [expr double([gi::findChild pulBLFld.value -in $dialog])];    set tr [expr double([gi::findChild pulTRFld.value -in $dialog])];    set purpw [gi::findChild purpFld -in $dialog];    set purp [gi::findChild purpFld.value -in $dialog];    set metal [gi::findChild metalFld.value -in $dialog];    set pitch [gi::findChild pitchFld.value -in $dialog];    array set clientData [db::getAttr cmd.clientData];    array set gridSpec $clientData(gridSpec);        if ![info exists gridSpec($metal)] {        lappend gridSpec($metal) $pitch;    }    set str [format "%-7s Wid=%5.3f Pos=%5.3f Net=%s pullBL=%1.3f pullTR=%1.3f" $purp $width $pos $name $bl $tr];    set wspec [list  $purp $width $pos [list pullBL $bl] [list pullTR $tr] [list name $name]]    if {"" != $stub} {        set str [format "%s Stub=%1.3f %1.3f %1.3f %1.3f" $str [lindex $stub 0] [lindex $stub 1] [lindex $stub 2] [lindex $stub 3]]        set off [expr double([lindex $stub 0])];          set len [expr double([lindex $stub 1])];            set spitch [expr double([lindex $stub 2])]          set minl [expr double([lindex $stub 3])]                        lappend wspec [list stub [list $off $len $spitch $minl]]    }    lappend items $str;    if [catch {db::setAttr defsFld.items -value $items}] return    db::setAttr defsFld.value -value [list $str]        set wspecs [lindex $gridSpec($metal) 1];    if [llength $wspecs] {        lappend wspecs $wspec        set gridSpec($metal) [lreplace $gridSpec($metal) 1 1 $wspecs]        } else {        set wspecs [list $wspec]        lappend gridSpec($metal) $wspecs        }    lappend gridSpec($metal) $wspec    set clientData(gridSpec) [array get gridSpec];    db::setAttr cmd.clientData -value [array get clientData];    [namespace current]::amdPDKLePwrGridUpd $cmd}                                proc amdPDKLePwrGridDelCB {cmd widget} {    set dialog [db::getAttr widget.parent];    set defsFld [gi::findChild defsFld -in $dialog];    set items [db::getAttr defsFld.items];    set value [db::getAttr defsFld.value];    set purpFld [gi::findChild purpFld -in $dialog];    db::setAttr purpFld.value -value track    if {"" == $value} {        de::sendMessage "Can't remove since nothing is selected" -severity warning;    }    set def [join $value];    set ind [lsearch $items $def];    set items [lreplace $items $ind $ind];    set metal [gi::findChild metalFld.value -in $dialog];    db::setAttr defsFld.items -value $items;    array set clientData [db::getAttr cmd.clientData];    array set gridSpec $clientData(gridSpec);        set specStr [string map {"Wid=" "" "Pos=" "" "Net=" "" "pullBL=" "" "pullTR=" "" "Stub=" ""} $def];    set purp [lindex $specStr 0];    set wid [expr double([lindex $specStr 1])];    set pos [expr double([lindex $specStr 2])];    set i 3;    set net ""    if [regexp {Net=} $def] {        set net [lindex $specStr $i];        incr i    }    set pBl [expr double([lindex $specStr $i])];    incr i       set pTr [expr double([lindex $specStr $i])];    incr i    set stb [lrange $specStr $i end]    set wspec [list $purp $wid $pos [list pullBL $pBl] [list pullTR $pTr]];    if {"" != $net} {        lappend wspec [list name $net]    }    if {"" != $stb} {        set off [expr double([lindex $stb 0])];          set len [expr double([lindex $stb 1])];            set spitch [expr double([lindex $stb 2])]          set minl [expr double([lindex $stb 3])]                        lappend wspec [list stub [list $off $len $spitch $minl]]    }    set wspecs [lindex $gridSpec($metal) 1]        set ind [lsearch $wspecs $wspec];    set wspecs [lreplace $wspecs $ind $ind];        set gridSpec($metal) [lreplace $gridSpec($metal) 1 1 $wspecs];    set clientData(gridSpec) [array get gridSpec];    db::setAttr cmd.clientData -value [array get clientData];    [namespace current]::amdPDKLePwrGridUpd $cmd    set purpFld [gi::findChild purpFld -in $dialog];    db::setAttr purpFld.value -value track}proc amdPDKLePwrGridNukeCB {cmd widget} {    set dialog [db::getAttr widget.parent];    set defsFld [gi::findChild defsFld -in $dialog];    set purpFld [gi::findChild purpFld -in $dialog];    db::setAttr purpFld.value -value track    set metal [gi::findChild metalFld.value -in $dialog];    if ![llength [db::getAttr defsFld.items]] return     db::setAttr defsFld.items -value [list];    array set clientData [db::getAttr cmd.clientData];    array set gridSpec $clientData(gridSpec);        set gridSpec($metal) [lreplace $gridSpec($metal) 1 1];    set clientData(gridSpec) [array get gridSpec];    db::setAttr cmd.clientData -value [array get clientData];    [namespace current]::amdPDKLePwrGridUpd $cmd}proc amdPDKLePwrGridNukeTracksCB {cmd widget} {    set dialog [db::getAttr widget.parent];    set purpFld [gi::findChild purpFld -in $dialog];    db::setAttr purpFld.value -value track    set defsFld [gi::findChild defsFld -in $dialog];    set items [db::getAttr defsFld.items]    set metal [gi::findChild metalFld.value -in $dialog];    array set clientData [db::getAttr cmd.clientData];    array set gridSpec $clientData(gridSpec);    set numTrack 0    foreach item $items {        if ![regexp {track} $item] continue        incr numTrack            set ind [lsearch $items $item];        set items [lreplace $items $ind $ind];        set specStr [string map {"Wid=" "" "Pos=" "" "Net=" "" "pullBL=" "" "pullTR=" "" "Stub=" ""} $item];        set purp [lindex $specStr 0];        set wid [expr double([lindex $specStr 1])];        set pos [expr double([lindex $specStr 2])];        set i 3        set net ""            if [regexp {Net=} $item] {            set net [lindex $specStr $i];            incr i        }        set pBl [expr double([lindex $specStr $i])];        incr i           set pTr [expr double([lindex $specStr $i])];        incr i        set stb [lrange $specStr $i end]        set wspec [list $purp $wid $pos [list pullBL $pBl] [list pullTR $pTr]];        if {"" != $net} {            lappend wspec [list name $net]        }        if {"" != $stb} {            set off [expr double([lindex $stb 0])];              set len [expr double([lindex $stb 1])];                set spitch [expr double([lindex $stb 2])]              set minl [expr double([lindex $stb 3])]                            lappend wspec [list stub [list $off $len $spitch $minl]]        }        set wspecs [lindex $gridSpec($metal) 1]        set ind [lsearch $wspecs $wspec];        set wspecs [lreplace $wspecs $ind $ind];            set gridSpec($metal) [lreplace $gridSpec($metal) 1 1 $wspecs];    }    if ![llength $numTrack] return     db::setAttr defsFld.items -value $items;    set clientData(gridSpec) [array get gridSpec];    db::setAttr cmd.clientData -value [array get clientData];    [namespace current]::amdPDKLePwrGridUpd $cmd    set purpFld [gi::findChild purpFld -in $dialog];    db::setAttr purpFld.value -value track}proc amdPDKLePwrGridMdirCB {cmd widget} {  variable updateFlag            set dialog [db::getAttr widget.parent];  set currMetal [gi::findChild  metalFld.value -in $dialog];  set mdir [db::getAttr widget.value];  array set AMDPDKgvarLibArray [db::getAttr cmd.clientData ];  set AMDPDKgvarLibArray([join [list PG $currMetal _dir] ""]) $mdir;  db::setAttr cmd.clientData -value [array get AMDPDKgvarLibArray];  [namespace current]::amdPDKLePwrGridUpdLbls $cmd $currMetal $dialog;  if $updateFlag {     [namespace current]::amdPDKLePwrGridUpd $cmd ;  }}      proc amdPDKLePwrGridDefCB {cmd widget} {    array set clientDataArray [db::getAttr cmd.clientData];    array set gridSpecArray $clientDataArray(gridSpec);    array set defGridSpecArray $clientDataArray(defGridSpec);    set dialog [db::getAttr widget.parent];    set metalFld [gi::findChild metalFld -in $dialog];    set metal [gi::findChild metalFld.value -in $dialog];    set enum [gi::findChild metalFld.enum -in $dialog];    if ![info exists defGridSpecArray($metal)] {        de::sendMessage "No default metal layer defined for $metal" -severity warning;        set nukeBut [gi::findChild nukeBut -in $dialog]        [namespace current]::amdPDKLePwrGridNukeCB $cmd $nukeBut        return    }            set gridSpecArray($metal) $defGridSpecArray($metal);    set clientDataArray(gridSpec) [array get gridSpecArray]    db::setAttr cmd.clientData -value [array get clientDataArray]    set ind [lsearch $enum $metal];    set length [llength $enum];    set nind [expr $ind + 1];    set nind [expr int([[namespace current]::amdPDKMod $nind $length])]     db::setAttr metalFld.value -value [lindex $enum $nind];    db::setAttr metalFld.value -value [lindex $enum $ind];    [namespace current]::amdPDKLePwrGridUpd $cmd}    proc amdPDKLePwrGridShowTemplate {widget} {    set path [db::getPrefValue amdPwrGrdTemplateFile];    if {"" == $path} {        set path [db::getPrefValue amdPwrGrdDefTemplateFile]        if {"" == $path} {            set cmd "Template Name Not Found"        } else {            set cmd $path        }    } else {        set cmd $path    }    set parent [db::getAttr widget.parent]    set dialog [gi::getDialogs templateFileDialog -parent $parent]        if [db::isEmpty $dialog] {        set dialog [gi::createDialog templateFileDialog -parent $parent \            -title "Selected Grid: Template File Name" -showHelp false ]        gi::layout [gi::createLabel templateFile -parent $dialog -label $cmd ] \            -rightOf [gi::createLabel templateFileIcon -parent $dialog -icon information_32 ]    }#    gi::prompt $cmd -title "Selected Grid: Template File Name" -buttons Done}proc filterGridCell {self selected} {    set lcv [db::getPrefValue amdPwrGrdCellView];       set grdCellLibName [lindex [split $lcv /] 0];       set grdCellName [lindex [split $lcv /] 1];       set grdCellViewName [lindex [split $lcv /] 2];    if {"Inst" == [db::getAttr selected.objType] && [db::getAttr selected.object.master.libName] == $grdCellLibName && [db::getAttr selected.object.master.cellName] == $grdCellName && [db::getAttr selected.object.master.viewName] == $grdCellViewName} {        return true    } else {        return false    }}proc copyToGridCell {cmd } {    set inst [db::getAttr cmd.engine.figure.object];    set design [db::getAttr editDesign -of [db::getNext [db::getAttr cmd.contexts]]];    array set AMDPDKgvarLibArray [db::getAttr cmd.clientData];    set mspecs [amd::_formatMspec $AMDPDKgvarLibArray(gridSpec)];    set minx [db::getParamValue minx  -of $inst]    set miny  [db::getParamValue miny -of $inst]        set maxx  [db::getParamValue maxx -of $inst]    set maxy  [db::getParamValue maxy -of $inst]    set trans [de::startTransaction "Copy Power Grid Spec" -design $design];     set app [oa::ParamArray];    db::setParamValue enable -type string -value  nil -of $inst;    amd::_setAppValue app mspecs $mspecs;    amd::_setAppValue app mdirections [db::getParamValue mdirections -of $inst]    amd::_setAppValue app stdViaList [db::getParamValue stdViaList -of $inst]     amd::_setAppValue app metallist [db::getParamValue metallist -of $inst]    amd::_setAppValue app opts [db::getParamValue opts -of $inst]                  oa::setParams $inst $app;    db::setParamValue minx -type float -value $minx  -of $inst    db::setParamValue miny -type float -value $miny  -of $inst    db::setParamValue maxx -type float -value $maxx  -of $inst    db::setParamValue maxy -type float -value $maxy  -of $inst    db::setParamValue enable -type string -value  toolPlaced -of $inst    de::endTransaction $trans    db::setAttr cmd.engine -value \        [de::createSelectionEngine -filterProc [namespace current]::filterSelected ]        db::setAttr cmd.prompt -value "Specify object to select"    }                proc amdPDKLePwrGridCopyTo {cmd widget} {    db::setAttr cmd.engine -value \        [de::createActivationEngine -filterProc [namespace current]::filterGridCell \        -objectPickProc [namespace current]::copyToGridCell ]    db::setAttr cmd.prompt -value "Pick target grid cell";               }proc copyFromGridCell {cmd} {    array set AMDPDKgvarLibArray [db::getAttr cmd.clientData];    set inst [db::getAttr cmd.engine.figure.object];    set mspecsParam [string map {"(" "{" ")" "}" "nil" "{}" "\"" ""} [db::getAttr inst.mspecs]];    set gridSpec [[namespace current]::buildMspecList $mspecsParam];    set AMDPDKgvarLibArray(gridSpec) $gridSpec;     db::setAttr cmd.clientData -value [array get AMDPDKgvarLibArray];    [namespace current]::amdPDKLePwrGridUpd $cmd    db::setAttr cmd.engine -value \        [de::createSelectionEngine -filterProc [namespace current]::filterSelected ]        db::setAttr cmd.prompt -value "Specify object to select"    }        proc amdPDKLePwrGridCopyFrom {cmd widget} {    db::setAttr cmd.engine -value \        [de::createActivationEngine -filterProc [namespace current]::filterGridCell \        -objectPickProc [namespace current]::copyFromGridCell ]    db::setAttr cmd.prompt -value "Pick the Grid Cell from which you want to copy spec";}    proc amdPDKLePwrGridLoad {cmd widget} {    set dialog [db::getAttr widget.parent]     set context [db::getNext [db::getAttr cmd.contexts]]    if [catch {amd::_amdPwrGridTemplate [db::getAttr cmd.dialog.parent.id] $context} error] {        de::sendMessage $error -severity error        return    }    array set PdkEnv $::amd::PdkEnv    array set clientDataArray [db::getAttr cmd.clientData];    array set  AMDPDKgvarLibArray  $amd::AMDPDKgvarLibList ;    array set defGridDirArray $PdkEnv(metalRoutingDirections);    if [info exists AMDPDKgvarLibArray(defGridDirs)] {        array set replacementArray $AMDPDKgvarLibArray(defGridDirs)        foreach metal [array names defGridDirArray] {            if [info exists replacementArray($metal)] {                 set defGridDirArray($metal) $replacementArray($metal)            }            }    }    set AMDPDKgvarLibArray(defGridDirs)    [array get defGridDirArray]    if [info exists AMDPDKgvarLibArray(defGridSpec)] {        foreach {metal def} $AMDPDKgvarLibArray(defGridSpec) {            lappend AMDPDKgvarLibArray(metals) $metal        }    } else {        de::sendMessage "Template file doesn't have metal definitions" -sevverity warning        return        }    set metalFld [gi::findChild metalFld -in $dialog]    db::setAttr metalFld.enum -value $AMDPDKgvarLibArray(metals);    db::setAttr metalFld.value -value [lindex $AMDPDKgvarLibArray(metals) 0]    foreach metal $AMDPDKgvarLibArray(metals) {        if [info exists defGridDirArray($metal)] {           set AMDPDKgvarLibArray([join [list PG $metal _dir] ""]) $defGridDirArray($metal);        } else {           set AMDPDKgvarLibArray([join [list PG $metal _dir] ""]) horizontal        }        set AMDPDKgvarLibArray([join [list PG $metal _viastyle] ""]) 2x2    }    array set gridSpecArray $clientDataArray(gridSpec)    set sortedMetals [lsort -command [list ::amd::_sortLayerByMaskNumber [db::getAttr context.editDesign]] [array names gridSpecArray]] ;    set m1 [lindex $sortedMetals 0];    set m2 [lindex $sortedMetals end]    set ind1 [lsearch $AMDPDKgvarLibArray(defGridSpec) $m1];    set ind2 [lsearch $AMDPDKgvarLibArray(defGridSpec) $m2];    if {0 > $ind1} {        de::sendMessage "New template file doesn't have $m1 metal definition" -severity error        return        } elseif {0 > $ind2} {        de::sendMessage "New template file doesn't have $m2 metal definition" -severity error        return        }     set AMDPDKgvarLibArray(gridSpec) [lrange $AMDPDKgvarLibArray(defGridSpec) $ind1 [incr ind2]]    set AMDPDKgvarLibArray(amdPwrGridVias)  $PdkEnv(pwrgridVias)    set AMDPDKgvarLibArray(instName) $clientDataArray(instName);    db::setAttr cmd.clientData -value [array get AMDPDKgvarLibArray];    [namespace current]::amdPDKLePwrGridUpd $cmd}            proc amdPDKLePwrGridSave {cmd widget} {    array set AMDPDKgvarLibArray [db::getAttr cmd.clientData];    array set gridSpecArray $AMDPDKgvarLibArray(gridSpec);    array set defGridSpecArray $AMDPDKgvarLibArray(defGridSpec);    set w [db::getAttr cmd.dialog.parent.id]    set filePath [db::getAttr widget.value]        set buffer ""    foreach layer $AMDPDKgvarLibArray(metals) {        if ![info exists defGridSpecArray($layer)] continue        set buffer [format "%sLAYER %s" $buffer $layer];        if ![info exists gridSpecArray($layer)] {            set buffer [format "%s Pitch=%5.3f\n" $buffer [lindex $defGridSpecArray($layer) 0]]            set buffer [format "%sENDLAYER\n" $buffer]            continue        }        set buffer [format "%s Pitch=%5.3f\n" $buffer [lindex $gridSpecArray($layer) 0]]        foreach wire [lindex $gridSpecArray($layer) 1] {            set purp    [lindex $wire 0];            set wid        [lindex $wire 1];              set pos        [lindex $wire 2];            set pbl        [lindex $wire 3 1];            set ptr        [lindex $wire 4 1];                set net        [lindex $wire 5 1];            if {"name" == [lindex $wire 5 0]} {                set buffer [format "%s WIRE %s Wid=%5.3f Pos=%5.3f Net=%s PullBL=%1.3f PullTR=%1.3f" $buffer $purp $wid $pos $net $pbl $ptr];            } else {                set buffer [format "%s WIRE %s Wid=%5.3f Pos=%5.3f PullBL=%1.3f PullTR=%1.3f" $buffer $purp $wid $pos $pbl $ptr];            }                           if {"stub" == [lindex $wire 6 0]} {                set buffer [format "%s Stub=%1.3f:%1.3f:%1.3f:%1.3f" $buffer [lindex $wire 6 1 0] [lindex $wire 6 1 1] [lindex $wire 6 1 2] [lindex $wire 6 1 3]]            }            set buffer [format "%s\n" $buffer]        }        set buffer [format "%sENDLAYER\n" $buffer]    }    set buffer  [format "%sOPTION %s\n" $buffer [lindex $AMDPDKgvarLibArray(defGridOpts) 0]]    foreach metal $AMDPDKgvarLibArray(metals) {        set dir $AMDPDKgvarLibArray([join [list PG $metal _dir] ""])        set buffer [format "%sVIA %s\n" $buffer $metal];        set buffer [format "%sDIR %s %s\n" $buffer $metal $dir];    }    set fd [open $filePath w]    puts $fd $buffer    close $fd    }proc setPwrGridSliceOptions {dialog} {}                proc amdPDKLePwrGridSliceForm {parent cmd} {    set context [db::getNext [db::getAttr cmd.contexts]]        set dialog [gi::createDialog pwrGridSliceOptionsDialog \        -parent $parent \        -title "Slicing Options" \        -execProc [namespace current]::setPwrGridSliceOptions \        -prefScope [db::getScopes $context] -showApply false];    gi::createMutexInput pwrGridSliceOptions \        -parent $dialog \        -enum {"Zero Pullbacks" "Zero Pullbacks Except to Cut" "Leave Pullbacks After Slicing"} \        -dataType sliceOptions -viewType radio  -prefName amdPwrGrdSliceOption    gi::execDialog $dialog       }proc amdPDKLePwrZeroPBs {cmd mspec edges zc} {    array set mspecArray $mspec;    set nmspec [list]    foreach metal [array names mspecArray] {        set pitch [lindex $mspecArray($metal) 0];        set wires [lindex $mspecArray($metal) 1];        set vorient [[namespace current]::amdPDKPwrGridIsLayVert $cmd $metal];        set nwires [list];        foreach wire $wires {            set purp [lindex $wire 0];            set width [lindex $wire 1];            set pos  [lindex $wire 2];            set pullBL [lindex $wire 3];            set pullTR [lindex $wire 4];            if $vorient {                if {[lsearch $edges T] > -1 && $zc } {set pullTR {pullTR 0.0}}                if {[lsearch $edges B] > -1 && $zc} {set pullBL {pullBL 0.0}}                if {[lsearch $edges CT] > -1 && $zc} {set pullTR {pullTR 0.0}}                if {[lsearch $edges CB] > -1 && $zc} {set pullBL {pullBL 0.0}}            } else {                if {[lsearch $edges R] > -1 && $zc } {set pullTR {pullTR 0.0}}                if {[lsearch $edges L] > -1 && $zc } {set pullBL {pullBL 0.0}}                if {[lsearch $edges CR] > -1 && $zc} {set pullTR {pullTR 0.0}}                if {[lsearch $edges CL] > -1 && $zc} {set pullBL {pullBL 0.0}}            }            set nwire [list $purp $width $pos $pullBL $pullTR] ;            if [llength [lrange $wire 5 end]] { set nwire [concat $nwire [lrange $wire 5 end]]}            lappend nwires $nwire        }        lappend nmspec $metal         lappend nmspec [list $pitch $nwires];    }    return $nmspec}proc amdPDKDbSliceBox {box1 box2} {    set minx1 [lindex $box1 0];    set miny1 [lindex $box1 1];    set maxx1 [lindex $box1 2];    set maxy1 [lindex $box1 3];        set minx2 [amd::_max $minx1 [lindex $box2 0]];    set miny2 [amd::_max $miny1 [lindex $box2 1]];    set maxx2 [amd::_min $maxx1 [lindex $box2 2]];    set maxy2 [amd::_min $maxy1 [lindex $box2 3]];        set tmp [list];    lappend tmp [list $minx1 $miny1 $minx2 $miny2 [list R T]]    lappend tmp [list $minx1 $miny2 $minx2 $maxy2 [list CR B T]]    lappend tmp [list $minx1 $maxy2 $minx2 $maxy1 [list R B]]        lappend tmp [list $minx2 $miny1 $maxx2 $miny2 [list L R CT]]    lappend tmp [list $minx2 $maxy2 $maxx2 $maxy1 [list L R CB]]    lappend tmp [list $maxx2 $miny1 $maxx1 $miny2 [list L T]]    lappend tmp [list $maxx2 $miny2 $maxx1 $maxy2 [list CL B T]]    lappend tmp [list $maxx2 $maxy2 $maxx1 $maxy1 [list L B]]    set res [list [list $minx2 $miny2 $maxx2 $maxy2 [list CL CR CB CT]]]    foreach item $tmp {        if {[lindex $item 0] < [lindex $item 2] && [lindex $item 1] < [lindex $item 3]} {            lappend res $item        }    }    return $res}proc amdSliceGrid {context cmd} {    db::setAttr cmd.prompt -value "";    array set AMDPDKgvarLibArray [db::getAttr cmd.clientData];    set mspec $AMDPDKgvarLibArray(gridSpec)    set gspec $AMDPDKgvarLibArray(gridSpec);    set gopts  $AMDPDKgvarLibArray(defGridOpts);    set metals $AMDPDKgvarLibArray(metals);    set mdirs "";    foreach metal  $metals {       lappend mdirs $metal;      lappend mdirs $AMDPDKgvarLibArray([join [list PG $metal _dir] ""]);   }    set mdirections [amd::formatMap $mdirs ];    set stdViaList     [amd::_formatLst $AMDPDKgvarLibArray(amdPwrGridVias)];    set opts         [amd::formatMap $gopts];    set metallist     [amd::_formatLst $metals]            set design [db::getAttr context.editDesign]    set inst [db::getNext [db::getInsts $AMDPDKgvarLibArray(instName) \        -of $design]]    set DBUperUU [db::getAttr design.dBUPerUU]        set points [db::getAttr cmd.engine.points];    set iminx [expr int([db::getParamValue minx -of $inst]*$DBUperUU) / double($DBUperUU)];    set imaxx [expr int([db::getParamValue maxx -of $inst]*$DBUperUU) / double($DBUperUU)];    set iminy [expr int([db::getParamValue miny -of $inst]*$DBUperUU) / double($DBUperUU)];    set imaxy [expr int([db::getParamValue maxy -of $inst]*$DBUperUU) / double($DBUperUU)];    set minx [lindex $points 0 0]     set miny [lindex $points 1 1]     set maxx [lindex $points 2 0]    set maxy [lindex $points 0 1]     set slices [[namespace current]::amdPDKDbSliceBox [list $iminx $iminy $imaxx $imaxy] [list $minx $miny $maxx $maxy]]    switch [db::getPrefValue amdPwrGrdSliceOption -scope $context] {        zeroPullbacks           {set zeroPBs 1 ; set zeroCenterPBs 1}        zeroExceptCutPullbacks  {set zeroPBs 1 ; set zeroCenterPBs 0}        leavePullbacks          {set zeroPBs 0 ; set zeroCenterPBs 0}    }    set trans [de::startTransaction "Slice Power Grid" -design $design];        foreach rest [lrange $slices 1 end] {        set newinst [le::copy $inst -anchor {0 0}];        set newinst [db::getNext $newinst]        set minx [lindex $rest 0];        set miny [lindex $rest 1];        set maxx [lindex $rest 2];        set maxy [lindex $rest 3];        set newspec [[namespace current]::amdPDKLePwrZeroPBs $cmd $mspec [lindex $rest 4] $zeroPBs]        set ispec [amd::_formatMspec $newspec]            set app [oa::ParamArray];        db::setParamValue enable -type string -value  nil -of $newinst        amd::_setAppValue app mspecs $ispec        amd::_setAppValue app mdirections $mdirections        amd::_setAppValue app stdViaList $stdViaList         amd::_setAppValue app metallist $metallist        amd::_setAppValue app opts $opts                   oa::setParams $newinst $app;        db::setParamValue minx -type float -value $minx  -of $newinst        db::setParamValue miny -type float -value $miny  -of $newinst        db::setParamValue maxx -type float -value $maxx  -of $newinst        db::setParamValue maxy -type float -value $maxy  -of $newinst        db::setParamValue enable -type string -value  toolPlaced -of $newinst    }    set minx [lindex $slices 0 0];    set miny [lindex $slices 0 1];    set maxx [lindex $slices 0 2];    set maxy [lindex $slices 0 3];    set newspec [[namespace current]::amdPDKLePwrZeroPBs $cmd $mspec [lindex $slices 0 4] $zeroCenterPBs]    set ispec [amd::_formatMspec $newspec]        set app [oa::ParamArray];    db::setParamValue enable -type string -value  nil -of $inst    amd::_setAppValue app mspecs $ispec    amd::_setAppValue app mdirections $mdirections    amd::_setAppValue app stdViaList $stdViaList     amd::_setAppValue app metallist $metallist    amd::_setAppValue app opts $opts               oa::setParams $inst $app;    db::setParamValue minx -type float -value $minx  -of $inst    db::setParamValue miny -type float -value $miny  -of $inst    db::setParamValue maxx -type float -value $maxx  -of $inst    db::setParamValue maxy -type float -value $maxy  -of $inst    db::setParamValue enable -type string -value  toolPlaced -of $inst    de::endTransaction $trans    db::setAttr cmd.engine -value \    [de::createSelectionEngine -filterProc [namespace current]::filterSelected ];    set prompt "Select Power Grid instance to modify";    db::setAttr cmd.prompt -value $prompt;}  proc amdPDKLePwrGridSlice {cmd widget} {    set context [db::getNext [db::getAttr cmd.contexts]];    array set AMDPDKgvarLibArray [db::getAttr cmd.clientData];    set mspec $AMDPDKgvarLibArray(gridSpec)    set tspec1 [[namespace current]::amdPDKLePwrZeroPBs $cmd $mspec [list] false]    set tspec2 [[namespace current]::amdPDKLePwrZeroPBs $cmd $mspec {L R T B} true]        if {$tspec1 != $tspec2} {        set dialog [db::getAttr widget.parent]         [namespace current]::amdPDKLePwrGridSliceForm $dialog $cmd    }    set prompt "Drag a rectangle to slice out of grid cell(s)"    db::setAttr cmd.engine -value \        [de::createShapeEngine  \            -shapeType rectangle \            -completeProc [list [namespace current]::amdSliceGrid $context]];    db::setAttr cmd.prompt    -value $prompt;}proc amdPDKLePwrGridPitchCB {cmd widget} {	variable updateFlag    set dialog [db::getAttr widget.parent];    set currMetal [gi::findChild  metalFld.value -in $dialog];    set pitch [db::getAttr widget.value];    array set AMDPDKgvarLibArray [db::getAttr cmd.clientData ];    set gridSpec $AMDPDKgvarLibArray(gridSpec);    array set gridSpecArray $gridSpec;    if [catch {set mspec $gridSpecArray($currMetal)} ] {		return	};    set gridSpecArray($currMetal) [lreplace $mspec 0 0 $pitch];    set AMDPDKgvarLibArray(gridSpec) [array get gridSpecArray];    db::setAttr cmd.clientData -value [array get AMDPDKgvarLibArray];	if $updateFlag {    	[namespace current]::amdPDKLePwrGridUpd $cmd ;	}}    proc buildDialog {cmd dialog} {    db::setAttr dialog.title -value "Power Grid Tool"    set trkLbl [gi::createLabel trkLbl -parent $dialog -label "Track-specific properties"]    set widthBut [gi::createPushButton widthBut -parent $dialog \        -label Width -execProc [list [namespace current]::amdPDKLePwrGridGetWidth $cmd]];    set widthFld [gi::createNumberInput widthFld -parent $dialog \        -value 0.0 -valueType float -width 8];       set posBut [gi::createPushButton posBut -parent $dialog \        -label Position -execProc [list [namespace current]::amdPDKLePwrGridGetPos $cmd]];    set posFld [gi::createNumberInput posFld -parent $dialog \        -value 0.0 -valueType float -width 8];    set nameFld [gi::createTextInput nameFld -parent $dialog -label netname -width 8];    set pulBLFld [gi::createNumberInput pulBLFld -parent $dialog \        -value 0.0 -valueType float -label "B/L Pullback"  -width 8];    set pulTRFld [gi::createNumberInput pulTRFld -parent $dialog \        -value 0.0 -valueType float -label "T/R Pullback" -width 8];#    set spltFld [gi::createBooleanInput split  -parent $dialog \#        -label "Allow split rail" -value false];    set stubFld [gi::createTextInput stubFld -parent $dialog -width 20 \        -label "Stub: Off Len Pitch MinL"];    gi::layout $widthFld -rightOf $widthBut -justify left;    gi::layout $posBut  -rightOf $widthFld     -justify right;    gi::layout $posFld -rightOf $posBut -justify left     gi::layout $nameFld -rightOf $posFld    gi::layout $nameFld -justify right;    #        gi::layout $spltFld -rightOf $nameFld -justify left      gi::layout $pulTRFld -rightOf $pulBLFld     gi::layout $pulBLFld -align $widthFld;    gi::layout $posFld -align $pulTRFld;    gi::layout $stubFld -rightOf $pulTRFld        set purps [db::getPrefValue amdPwrgridPurposes]     set purpFld [gi::createMutexInput purpFld -parent $dialog \        -enum $purps -radioRows 3 -value track -viewType radio \        -valueChangeProc [namespace current]::amdPDKLePwrGridPurpChange]    gi::createGroup -decorated false -parent $dialog        set addBut [gi::createPushButton addBut -parent $dialog \    -label Add -execProc [list [namespace current]::amdPDKLePwrGridAddCB $cmd]];        set delBut [gi::createPushButton delBut -parent $dialog \    -label Delete -execProc [list [namespace current]::amdPDKLePwrGridDelCB $cmd]];        set modBut [gi::createPushButton modBut  -parent $dialog \    -label Modify -execProc [list [namespace current]::amdPDKLePwrGridModCB $cmd]];    #    set grabBut [gi::createPushButton grabBut -parent $dialog \#    -label Grab  -execProc amdPDKLePwrGridGrab];        set nukeBut [gi::createPushButton nukeBut -parent $dialog \    -label "Nuke All"  -execProc [list [namespace current]::amdPDKLePwrGridNukeCB $cmd]];        set nukTBut [gi::createPushButton nukTBut -parent $dialog \    -label "Nuke Tracks" -execProc [list [namespace current]::amdPDKLePwrGridNukeTracksCB  $cmd]];        set defBut [gi::createPushButton defBut -parent $dialog \    -label "Default Defs" -execProc [list [namespace current]::amdPDKLePwrGridDefCB $cmd] ];    gi::layout $modBut -rightOf $addBut -justify left ;    gi::layout $delBut -rightOf $modBut -justify left ;#    gi::layout $grabBut -rightOf $delBut -justify left ;    gi::layout $defBut -rightOf $delBut -justify right    gi::layout $nukeBut -leftOf $defBut -justify right ;    gi::layout $nukTBut -leftOf $nukeBut -justify right ;    set defsFld [gi::createListInput defsFld -parent $dialog -items {} \        -selectionModel single -viewType list \        -valueChangeProc [list [namespace current]::amdPDKLePwrGridSelectCB $cmd]]    set layLbl [gi::createLabel layLbl -parent $dialog -label "Layer-specific properties"]    set metals [list] ;     array set AMDPDKgvarLibArray [db::getAttr cmd.clientData];    set metals $AMDPDKgvarLibArray(metals)    set metalFld [gi::createMutexInput metalFld -parent $dialog \        -label "Edit Layer" -enum $metals -value "" \        -viewType combo \        -valueChangeProc [list [namespace current]::amdPDKLePwrGridRefreshList $cmd]];    set pitchLbl [gi::createLabel pitchLbl -parent $dialog     -label Pitch]        set pitchFld [gi::createNumberInput pitchFld -parent $dialog -width 8 \        -value 0.0 -valueType float -valueChangeProc [list [namespace current]::amdPDKLePwrGridPitchCB $cmd]];    set spullBLBut [gi::createLabel spullBLBut -parent $dialog     -label "B/L Pullback" -enabled false]        set spulBLFld [gi::createTextInput spullBLFld -parent $dialog -width 8 -enabled false];    set spullTRBut [gi::createLabel spullTRBut -parent $dialog -label "T/R Pullback" -enabled false]    set spulTRFld [gi::createTextInput spulTRFld -parent $dialog  -width 8 -enabled false];    gi::layout $spullBLBut -after $layLbl -justify left;    gi::layout $spulBLFld -rightOf $spullBLBut -justify left;    gi::layout $spullTRBut -rightOf $spulBLFld -justify left;       gi::layout $spulTRFld -rightOf $spullTRBut -justify left;    gi::layout $pitchLbl -rightOf $spulTRFld -justify left;    gi::layout $pitchFld -rightOf $pitchLbl -justify left;    gi::layout $metalFld -align $spulBLFld;    set mdirLbl [gi::createLabel mdirLbl -parent $dialog -label "Metal Dir:"]    set mdirFld [gi::createMutexInput  mdirFld -parent $dialog  \        -value horizontal -enum {horizontal vertical} \        -valueChangeProc [list [namespace current]::amdPDKLePwrGridMdirCB $cmd]]    gi::layout $mdirFld -rightOf $mdirLbl -justify left        set opsLbl [gi::createLabel opsLbl -parent $dialog -label "Global operations"];    set copyTBut [gi::createPushButton copyTBut -parent $dialog -label "Copy To" \        -execProc [list [namespace current]::amdPDKLePwrGridCopyTo $cmd]]    set copyFBut [gi::createPushButton copyFBut -parent $dialog -label "Copy From" \           -execProc [list [namespace current]::amdPDKLePwrGridCopyFrom $cmd]];#set abutBut [gi::createPushButton abutBut -parent $dialog -label "Abut To" \#            -execProc amdPDKLePwrGridAbutTo];    set sliceBut [gi::createPushButton sliceBut -parent $dialog -label "Slice Grid"\        -execProc [list [namespace current]::amdPDKLePwrGridSlice $cmd] -enabled true];    set fileFld [gi::createPushButton fileFld -parent $dialog -label "Query Template Filename" \        -execProc [namespace current]::amdPDKLePwrGridShowTemplate];    set loadBut [gi::createPushButton loadBut -parent $dialog -label "Load frm File" \        -execProc [list [namespace current]::amdPDKLePwrGridLoad $cmd]];#        set saveBut [gi::createPushButton saveBut -parent $dialog -label "Save to File" \        -execProc  [list [namespace current]::amdPDKLePwrGridSave $cmd]];    set saveBut [gi::createFileInput saveBut -parent $dialog \        -fileMasks {{*} {*.*} {*.template}} -mode save \        -valueChangeProc  [list [namespace current]::amdPDKLePwrGridSave $cmd]];    set children [gi::findChild saveBut.children -in $dialog];    set bb [db::filter $children -filter {%name == "browseButton"}];    db::setAttr label -of $bb -value "Save to File"    db::setAttr icon -of $bb -value ""    db::setAttr shown -of [db::filter $children -filter {%name == "entryField"}] -value false    #   set changeBut [gi::createPushButton changeBut -parent $dialog -label "Changed grids being modified" \#            -execProc amdPDKLePwrGridSel];#   set copyLFld [gi::createMutexInput copyLFld -parent $dialog -enabled false \        -enum {"All" "Just Vert" "Just Horiz"} -value All -viewType radio];    gi::layout $copyFBut -rightOf $copyTBut -justify left;    gi::layout $sliceBut -rightOf $copyFBut -justify right ;#   gi::layout $changeBut -rightOf $copyLFld    gi::layout $fileFld  -rightOf $sliceBut ; # -align $changeBut ;    gi::layout $loadBut  -rightOf $fileFld -justify right ;    gi::layout $saveBut -rightOf $loadBut -justify right ;    array set AMDPDKgvarLibArray [db::getAttr cmd.clientData];    if {![info exists AMDPDKgvarLibArray(gridSpec)] || ![llength $AMDPDKgvarLibArray(gridSpec)] } {        set curMetal [lindex $AMDPDKgvarLibArray(metals) 0]    } else {        set curMetal [lindex $AMDPDKgvarLibArray(gridSpec) 0];    }    db::setAttr metalFld.value -value $curMetal    set design [db::getAttr editDesign -of [db::getNext [db::getAttr cmd.contexts]]];    after idle [namespace current]::selectionChanged $cmd $design    }}set arg [list]lappend arg [de::createArgument -instName -description "Power Grid inst Name" -optional true ] lappend arg [de::createArgument -gridSpec -description "Power Grid spec" -optional true -isList true] de::createCommand amd::editPDKLePwrGrid -type interactive -arguments $arg \    -description "Edit Power Grid" -category layout -label "Power Grid" \    -requiresWriteMode trueunset argdb::setPrefValue amdEditPDKLePwrGridDialogMode -value true